#! /usr/bin/env python
# -*- coding: utf-8 -*-

# # # # # # # # # # # # # # # # # # # # # # # #
#	TRADUCTORES E INTERPRETADORES CI3725      #
#	Primera entrega del proyecto.             #
#   Lexer para el lenguaje Setlan             #
#	Autores: Carlos Martínez 	- 11-10584    #
#			 Christian Teixeira - 11-10584    #
# # # # # # # # # # # # # # # # # # # # # # # #

import ply.lex as lex

# Declaración de tokens

tokens = (
		'PROGRAM',
		'LCURLY',
		'RCURLY',
		'LPAREN',
		'RPAREN',
		'PRINT',
		'PRINTLN',
		'IN',
		'USING',
		'INT',
		'BOOL',
		'SCAN',
		'IDENTIFIER',
		'COMMA',
		'DOT',
		'SEMICOLON',
		'COLON',
		'ASSIGN',
		'STRING',
		'PLUS',
		'MINUS',
		'IF',
		'ELSE',
		'TRUE',
		'OR',
		'AND',
		'NOT',
		'FALSE',
		'FOR',
		'REPEAT',
		'WHILE',
		'DO',
		'SET',
		'LESSTHAN',
		'GREATERTHAN',
		'LTOREQUAL',
		'GTOREQUAL',
		'EQUAL',
		'NOTEQUAL',
		'ASTERISK',
		'DEF',
		'RETURN',
		'ARROW',
		'INTDIV',
		'PERCENT',
		'ARROBA',
		'UNION',
		'INTERSECTION',
		'COMPLEMENT',
		'SETSUM',
		'SETREST',
		'SETSUBSTRACT',
		'SETMULT',
		'SETDIV',
		'SETMOD',
		'SETMAX',
		'SETMIN',
		'SETLENGTH',
		'INTEGER',
	)

# Diccionario de reserveds

reserved = {
	'program' : 'PROGRAM',
	'print' : 'PRINT',
	'println' : 'PRINTLN',
	'using' : 'USING',
	'int' : 'INT',
	'bool' : 'BOOL',
	'scan' : 'SCAN',
	'if' : 'IF',
	'else' : 'ELSE',
	'in' : 'IN',
	'true' : 'TRUE',
	'false' : 'FALSE',
	'or' : 'OR',
	'and' : 'AND',
	'not' : 'NOT',
	'for' : 'FOR',
	'repeat' : 'REPEAT',
	'while' : 'WHILE',
	'do' : 'DO',
	'set' : 'SET',
	'def' : 'DEF',
	'return' : 'RETURN',
}

# Reglas simples para reconocer los tokens

t_LCURLY = r'\{'
t_RCURLY = r'\}'
t_LPAREN = r'\('
t_RPAREN = r'\)'
t_PLUS = r'\+'
t_MINUS = r'-'
t_SEMICOLON = r';'
t_COLON = r':'
t_COMMA = r','
t_DOT = r'\.'
t_ASSIGN = r'='
t_ARROW = r'->'
t_GREATERTHAN = r'>'
t_LESSTHAN = r'<'
t_GTOREQUAL = r'>='
t_LTOREQUAL = r'<='
t_EQUAL = r'=='
t_NOTEQUAL = r"/="
t_ASTERISK = r'\*' 
t_ARROBA = r'@'
t_INTDIV = r'/'
t_PERCENT = r'%'
t_UNION = r'\+\+'
t_INTERSECTION = r'><'
t_COMPLEMENT = r'\\'
t_SETSUM = r'<\+>'
t_SETSUBSTRACT = r'<->'
t_SETMULT = r'<\*>'
t_SETDIV = r'</>'
t_SETMOD = r'<%>'
t_SETMAX = r'>\?'
t_SETMIN = r'<\?'
t_SETLENGTH = r'\$\?'
t_ignore  = ' |\t'

# Reglas más complicadas que requieren de función

def t_INTEGER(t):
    r'\d+'
    t.value = int(t.value)    
    return t

def t_STRING(t):
    r'"(?:[^"\\]|\\.)*"'
    while t.value.count(r'\"') > 0 :
        if t.value.count(r'\"') > 0:
            t.value = t.value[:t.value.find(r'\"')] + t.value[t.value.find(r'\"')+1:]
    aux = t.value.count(r'\\')
    while aux > 0 :
        if t.value.count(r'\\') > 0:
            t.value = t.value[:t.value.find(r'\\')] + t.value[t.value.find(r'\\')+1:]
            aux = aux - 1 
    return t

def t_IDENTIFIER(t):
	r'[a-zA-Z_][a-zA-Z0-9_]*'
	t.type = reserved.get(t.value,'IDENTIFIER')
	return t

def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

def t_ignore_comment(t):
	r'\#.*'
	pass

# Función que atrapa expresiones no reconocidas

def t_error(t):
	error.append(t)  # Se incluyen en la lista de error
	t.lexer.skip(1)

# main del programa

def main(argv  = None):
	import sys
	if(argv is None):
		argv = sys.argv
	if(len(argv) == 1):
		print("ERROR: No se encontró argumento.\nUso: ./setlan [Nombre_Archivo]\nPor favor verifíque que el archivo existe en su directorio y está correctamente escrito.")
		exit(1)

	global error
	error = []
	out = []
	nombreArchivo = argv[1]
	archivo = open(nombreArchivo, "r")
	contenido = archivo.read()

	lexer = lex.lex()
	lexer.input(contenido)

	# Loop para extraer tokens correctos

	while True:
		tok = lexer.token()
		if not tok: break
		out.append(tok)		# Se incluyen en la lista de out

	# Imprimir resultados

	if len(error) == 0:	# Lista de error vacía, se imprimen los tokens correctos
		for t in out:
			if(t.type == "IDENTIFIER" or t.type == "SETSUBSTRACT"):
				print("token " + str(t.type) + "\tvalue (" + str(t.value) + ") at line " + str(t.lineno) + ", column " + str(t.lexpos))
			else:
				print("token " + str(t.type) + "\t\tvalue (" + str(t.value) + ") at line " + str(t.lineno) + ", column " + str(t.lexpos))
	else:				# Lista de error no vacía, se imprimen solo los tokens de error encontrados
		for t in error:
			print("Error: Se encontró un caracter inesperado \"" + t.value[0] + "\" en la Línea " + str(t.lineno) + ", Columna " + str(t.lexpos) + ".")

if __name__ == "__main__":
	main()