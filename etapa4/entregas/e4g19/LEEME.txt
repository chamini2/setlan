--------------------------------------------------------------------------------
--------------------------------------------------------------------------------                                                                               
                                    SETLAN                                      
									Etapa 4
	Analizador Lexicográfico, Sintáctico, con Verificación de tipos y Ejecucion 
								de instrucciones
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

Autores
-------
11-10097 Gustavo Benzecri
11-10500 David Klie


Última modificación
-------------------
8 de marzo de 2015


Descripción del programa
------------------------
Las cuatro etapas del interpretador para el lenguaje Setlan, 
implementación del analizador lexicográfico,sintactico, con chequeo de tipos y 
ejecucion de instrucciones. 
Siguiendo las especificaciones de la definición del lenguaje se identifican los 
tokens relevantes, se reconocen con expresiones regulares y se implanta el 
analizador utilizando la herramienta PLY (Python Lex-Yacc) para Python.

Se verifica la correctitud de las expresiones, uso de variables 
declaradas dentro de los contextos, la no modificacion de las variables de 
iteración y errores de declaraciones.

Al finalizar el análisis lexicográfico, sintáctico y de correctitud de expresiones
se procede a ejecutar el programa.


Ejecución
---------
Windows:
1. Extraer todos los archivos de setlan.tar.gz en un directorio
2. Renombrar el ejecutable como setlan.py
3. Cambiar al directorio donde se encuentra el programa
4. Ejecutar el programa con el comando 'python setlan.py <fuente.stl>'

Linux:
1. Extraer todos los archivos de setlan.tar.gz en un directorio
2. Cambiar al directorio donde fueron extraidos los archivos
3. Ejecutar el comando 'chmod +x setlan' para otorgarle permiso de ejecución
4. Ejecutar el programa con el comando './setlan <fuente.stl>'


Decisiones de implementación
----------------------------
- Se realiza un cheque de argumentos al principio del main para verificar 
si existeun archivo fuente.

- La salida del t_error fue redireccionada a la salida de error. Sólo sale por
ahí si es llamada la función t_error.

-Se cambia le modo de recolectar  los errores ahora hay una lista de errores para el lexer
y otra lista de errores para el parser, se recolectan los errores en la funciones de error
y se muestran todos los errores del lexer y de no haber se muestra solo el primero del parser

-Se definio la gramatica del lenguaje

- Se hizo una distincion entre las posibles instrucciones

-Para evitar conflictos shift/reduce se define una precedencia especial para los if statements
sin else y los que tienen else los que tienen else tienen mas alta precedencia.

-Inicialmente se hizo una distincion entre los distintos tipos de expresion 
pero por conflictos con las variables, que pueden ser de cualquier tipo, 
se decidió no hacer distinción entre las expresiones.

-Se crea un modulo arbol con todas las clases consideradas para general el AST
-Se tiene una funcion especial para cada clase printTree que imprime con la idemtación adecuada
- Se implementan las funciones createTable dentro de los nodos Do,Repeat,If,Else, For y Block que genera
una tabla de simbolos si se puede.

-Se implementa en los nodos restantes de tipo statement una funcion de correctitud 
que verifica que la instruccion sea válida en cuanto a los tipos que esta requiera

-Se implementa para las expresiones la funcion returnType que devuelve un tipo 
reconocido por setlan si la expresion evaluada es correcta o None si la 
expresion es incorrecta.

- Se tiene un nuevo módulo llamado SymbolTable que contiene una clase llamada 
SymbolTable que es la estructura donde se almacenan las variables dentro de un 
contexto específico.

- Se tiene una pila de tablas de simbolos donde se van colocando las tablas en 
el orden en el que van apareciendo. Una vez que la tabla sea desempilada 
significa que el programa no utilizará mas las variables que aparecen en ese contexto. 

- Se modificó la gramática de forma que se ajustara a los requerimientos del lenguaje.

- Se tienen una lista de errores que pudieran ocurrir durante las verificaciones de tipos, expresiones...
la lista es una variable global

-Se implementa para las expresiones una funcion de tipo evaluate que devuelve el 
valor mas simple de una expresion. 

-Las expresiones binarias y unarias tienen un diccionario, como variable de clase
que son de la forma (<Simbolo del operador>, <Funcion del operador>) de manera que
si se reconoce el simbolo '+' el diccionario devolvería la funcion primitiva de 
python operator.add a la cual solo habría que pasarle los argumentos que el AST
contenga para calcular el valor. es una excepción pues tiene una función evaluate
porque while es solo una guarda.

-Las instrucciones tienen una funcion llamada execute que realiza la ejecución
de las instrucciones. La instruccion while 

-Se dejaron los flags -a -t -s pero ahora al ejecutar setlan sin flags se ejecutará
el programa. Si tiene flags se mostraran los valores indicados por estos menos
la ejecucion.

-Las tablas de simbolos ahora tienen valores de python. 

- En la implementación de Scan, de decidió que se podían aceptar expresiones 
aritméticas. Entonces si se tiene una variable x de tipo int y se ejecuta la instrucción 
scan x entonces la introducción de la expresion -5+5*4+8%9 es una expresion reconocida
. Note que scan x con la expresion -5+5*4+8%9 equivale a hacer scan x introduciendo
23. Introducir una expression ((4) daría error. 

Estado actual del proyecto
--------------------------
El lexer fue implementado exitosamente. Se realizaron un total de 20 pruebas 
normales y de casos frontera para verificar que funcione bien y que reconozca 
correctamente todo el lenguaje.

El analizador sintáctico fue implementado exitosamente. Pasa los casos de prueba mostrados 
y reporta los errores adecuados cuando hay errores de sintaxis o lexicos.

-El proyecto se puede dar por terminado.


Problemas presentes
-------------------
- Los errores de tipos se reportan según la linea de la isntruccion. Las columnas no son del todo 
precisas pero siempre en una zona proxima a el problema. Una instruccion que acaba en SEMICOLON (;)
reporta un error, si lo tiene en la columna donde esta el (;) que finaliza la instruccion. En el caso
de un if o un for en la columna donde termine esa parte de la instruccion por ejemplo en un 
if (2+6) { ... } el error se reportaría al final del parentesis de la condición.

- En la implementación de la ejecucion. El cambio de la estructura de conjunto 
a la estructura de python para conjuntos hace que la tabla de simbolos imprima los
conjuntos como set([<elementos>]) en vez de {<elementos>}. Esto no afecta 
a print o println de setlan.

- Al hacer print de un booleano este se escribirá con la primera letra en mayuscula
Ejm: True, False. Pues python los representa de esta manera. 


Changelog
---------
2015-1-21  David Klie  <mangok543@gmail.com>

    * setlan.py: Primer avance de Setlan
    	- Definición de los tokens
	- Definición de las palabras reservadas
	- Implementación de las funciones de reconocimiento complejas
	- Definición de las líneas ignoradas y el reconocimiento de errores

2015-1-21  Gustavo Benzecri  <gebenzecri@gmail.com>

    * setlan.py: Versión funcional
	- Implementación de las funciones de reconocimiento complejas
	- Lectura de un archivo fuente para hacerle un análisis lexicográfico
	
2015-1-22  David Klie  <mangok543@gmail.com>

    * setlan.py: Modificación de detalles
	- Redireccionamente de las salida estándar a la salida de error
	- Implementación del chequeo de argumentos de entrada
	
2015-1-22  Gustavo Benzecri <gebenzecri@gmail.com>

    * setlan.py: Versión totalmente funcional
    - Mejora de las expresiones regulares para mejor reconocimiento
	- Pruebas extensivas con varios códigos fuentes
	- Corrección de bugs en las funciones
	
2015-1-22  David Klie <mangok543@gmail.com>
    
	* setlan.py: Ejecución de casos de prueba
	- Pruebas extensivas con varios códigos fuentes
	- Corrección de bugs en las funciones
	
2015-1-23  Gustavo Benzecri <gebenzecri@gmail.com>
    
	* setlan.py: Ejecución de casos de prueba y documentación
	- Refactorización de algunos elementos del código
	- Realización de pruebas de regresión
	- Documentación del programa y elaboración del LEÉME

2015-1-23  David Klie <mangok543@gmail.com>
    
	* setlan.py: Refactorización y más casos de prueba
	- Refactorización del código para adaptarse al formato de la entrega
	- Se probró con 3 casos de prueba más
2015-2-3 David Klie <mangok543@gmail.com>
	* setlan : pasa a ser setlanlex.py
	- setlan : se crea este nuevo modulo con el paser
	- setlan : se definen algunas reglas gramaticales

2015-2-5 Gustavo Benzecri <gebenzecri@gmail.com> David Klie <mangok543@gmail.com>
	* setlanlex.py : se elimina el main 
	- setlan : se definen todas las reglas gramaticales
	- Arbol.py: Se crea el modulo con las clases del AST, se crean varias clases

2015-2-7 David Klie Gustavo Benzecri
	-Arbol.py : Se terminan de implementar todas las clases del AST
	-setlan : Se implementan completamente las gramaticas y se definen las precedencias
	-Arbol.py : Se modifican algunas clases que presentaban problemas

2015-2-8 David Klie Gustavo Benzecri
	-Se realizan las pruebas y se depuran algunos errores.

2015-2-15 Gustavo Benzecri <gebenzecri@gmail.com> David Klie <mangok543@gmail.com>
	-SymbolTable.py Se crea nuevo modulo con la tabla de simbolos y la pila que se utilizará
	-setlanparser.py se renombra el modulo setlan a setlanparser
	-setlan: se crea un módulo 'main' que importara el lexer, parser, tabla de simbolos y los nodos para realizar la tabla de simbolos

2015-2-16 y 17: Gustavo Benzecri <gebenzecri@gmail.com> David Klie <mangok543@gmail.com>
	-Se implementan las funciones createTable, isCorrect de los nodos de tipo Statement
	-Se implementan las funciones returnType de los nodos de tipo expression
	-Se hacen pruebas preliminares

2015-2-21 Gustavo Benzecri <gebenzecri@gmail.com> David Klie <mangok543@gmail.com>
	-Se implementa la regla de que las variables de iteración de un ciclo for no pueden ser modificadas. 
	-Se realiza una modificación en la busqueda de variables en la tabla de símbolos para que solo consiga la primera ocurrencia del identificador buscado
	- Se implementan los comandos -t -a y -s del módulo setlan para que imprima, la lista de tokens, arbol sintáctico ó la tabla de simbolos.
	- Se modifica la gramática: ahora Block se deriva desde statement, todas las derivaciones que tenian block desaparecen, solo quedan las que tienen statement. 

2015-2-21 Gustavo Benzecri <gebenzecri@gmail.com> David Klie <mangok543@gmail.com>
	- Se modifica la expresion regular asociada con los strings en el lexer
	- Se hacen pruebas para verificar que la expresion regular es correcta
	- Pruebas de regresión.
	
2015-3-3 Gustavo Benzecri <gebenzecri@gmail.com> David Klie <mangok543@gmail.com>
	- Se implementa la evaluacion de las expresiones. Expresiones base de conjunto
entero, variable, booleano.
	- Se implementa la evaluación de las expresiones unarias.
	- Se implementa la evaluación de las expresiones Binarias.
	- Se implementa la instruccion de asignación y de bloque.
	- Se modifican los valores iniciales de la tabla de simbolos para funcionar con
python.
	
2015-3-6 Gustavo Benzecri <gebenzecri@gmail.com> David Klie <mangok543@gmail.com>
	- Se implementan las estructuras de control if, repeat, while y do.
	
2015-3-7 Gustavo Benzecri <gebenzecri@gmail.com> David Klie <mangok543@gmail.com>
	- Se implementan las estructuras de for, repeat_while_do y por ultimo scan.
	- Se arreglan defectos con la estructura de conjunto.
	-Se modifica el main para la ejecucion del programa sin la ejecucion de otros 
flags
	- Se mantienen los flags
	- Se hacen pruebas para ver que no se haya quebrado nada
	
2015-3-8 Gustavo Benzecri <gebenzecri@gmail.com> David Klie <mangok543@gmail.com>
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
