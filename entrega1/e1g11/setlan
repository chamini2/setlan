#!/usr/bin/env python
# -*- coding: utf-8 -*-

#Jesus Sanchez 10-10898
#Jose Barrientos 10-10800
#Entrega 1 ci-3725

import ply.lex as lex
import sys

#inicializacion de listas de tokens y errores encontrados
lexer_tokens = []
lexer_errores = []

#lista de palabras reservadas
reserved = {
    'if' : 'IF',
    'else' : 'ELSE',
    'while' : 'WHILE',
    'do' : 'DO',
    'for' : 'FOR',
    'repeat' : 'REPEAT',
    'in' : 'IN',
    'def' : 'DEF',
    'return' : 'RETURN',
    'program' : 'PROGRAM',
    'using' : 'USING',
    'set' : 'SET',
    'print' : 'PRINT',
    'println' : 'PRINTLN',
    'bool' : 'BOOL',
    'int' : 'INT',
    'scan' : 'SCAN',
    'not' : 'NOT',
    'and' : "AND",
    'or' : "OR",
    'min' : "MIN",
    'max' : "MAX"	
}

#lista de tokens definidos
tokens = list(reserved.values()) + [

    'NUMERO','TRUE','FALSE','STRING','ID',
    'PLUS','MINUS','TIMES','DIVIDE','LPAREN','RPAREN',
    'SEMICOLON','EQUIV','ASIGNA','COMA','MODULE',
    'LESSTEQ','LESST','GREATEQ', 'GREATT','NOTEQ',
    'DOSPUN','FLECHA', 'UNION', 'DIFERENCIA',
    'INTERSECT', 'PLUSCONJ', 'MINUSCONJ','TIMESCONJ',
    'DIVCONJ','RESTOCONJ','MAXCONJ', 'MINCONJ',
    'SIZECONJ', 'CONTIENECONJ','LLAVEIZ', 'LLAVEDE'
	
]

#expresiones regulares para atrapar tokens

t_PLUS    = r'\+'
t_MINUS   = r'-'
t_TIMES   = r'\*'
t_DIVIDE  = r'/'
t_LPAREN  = r'\('
t_RPAREN  = r'\)'
t_SEMICOLON = r';'
t_EQUIV = r'=='
t_ASIGNA = r'='
t_COMA = r','
t_MODULE = r'%'
t_LESSTEQ = r'<='
t_LESST = r'<'
t_GREATEQ = r'>='
t_GREATT = r'>'
t_NOTEQ = r'/='
t_DOSPUN = r':'
t_FLECHA  = r'->'
t_UNION  = r'\+\+'
t_DIFERENCIA  = r'\\\\'
t_INTERSECT  = r'><'
t_PLUSCONJ  = r'<\+>'
t_MINUSCONJ  = r'<\->'
t_TIMESCONJ  = r'<\*>'
t_DIVCONJ  = r'</>'
t_RESTOCONJ  = r'<%>'
t_MAXCONJ  = r'>\?'
t_MINCONJ  = r'<\?'
t_SIZECONJ  = r'\$\?'
t_CONTIENECONJ  = r'@'
t_LLAVEIZ = r'{'
t_LLAVEDE = r'}'
t_ignore  = ' \t'

#funcion que identifica un token NUMERO y guarda su valor entero
def t_NUMERO(t):
    r'\d+'
    if((int(t.value)>2147483647) or (int(t.value)+ 2147483648)<0):
        print "El numero introducido excede 32 bits"
        exit(0)
    else:
        t.value = int(t.value)
    return t

#funcion que identifica un token TRUE y guarda su valor booleano
def t_TRUE(t):
    r'(\btrue\b)'
    t.value = bool(t.value)
    return t

#funcion que identifica un token FALSE y guarda su valor booleano
def t_FALSE(t):
    r'(\bfalse\b)'
    t.value = bool("")
    return t

#funcion que identifica un token STRING y lo retorna
def t_STRING(t):
    r'\"([^\n\"\\]|\\n|\\"|\\\\)*\"'
    return t

#funcion que identifica un token ID para nombres de variables
def t_ID(t):
    r'[a-zA-Z_][a-zA-Z_0-9]*'
    t.type = reserved.get(t.value,'ID')
    return t

#metodo que identifica saltos de linea
def t_newline(t):
    r'\n+'		
    t.lexer.lineno += len(t.value)
	
#metodo que identifica comentarios
def t_COMMENT(t):
    r'\#.*'	

#funcion que calcula la columna de la palabra o simbolo que lee actualmente
def calcular_columna(input, tok):
    ultimo_salto = input.rfind('\n', 0, tok.lexpos)
    if ultimo_salto < 0:
        ultimo_salto = 0
    else:
        ultimo_salto += 1;
    columna = (tok.lexpos - ultimo_salto) + 1
    return columna

#metodo que almacena palabras o simbolos inesperadas en la lista de errores
def t_error(t):
    lexer_errores.append("Error: Se ha conseguido un caracter inesperado '%s' en linea %s, columna %s." %(t.value[0],t.lineno,str(calcular_columna(t.lexer.lexdata,t))))
    t.lexer.skip(1)


#metodo que almacena palabras o simbolos en la lista de tokens encontrados
def buscar(input, lexer):
    global lexer_tokens
    lexer.input(input)
    while True:
        tok = lexer.token()
        if not tok:
            break
        lexer_tokens.append(tok)

#metodo que imprime los resultados obtenidos al finalizar la lectura
def imprimir(input, lexer):
    buscar(input, lexer)
    
    if len(lexer_errores) > 0:
        for tok in lexer_errores:
            print(tok)
    else:
        for tok in lexer_tokens:
            print "Un Token %s (%s) (Linea %s, Columna %s)" % (tok.type, tok.value, tok.lineno,str(calcular_columna(input,tok)))

            	
            
lexer = lex.lex()

#Principal
if __name__ == '__main__':
    if(len(sys.argv) != 2):
        print "Falta un argumento en su entrada. \nDebe seguir el formato: ./setlan Archivo.stl"
    else:
        archivo = sys.argv[1]
        data=""
        try:
            fh = open(archivo, 'r')
            data = fh.read()
            fh.close()
        except IOError:
            print 'No se puede abrir el archivo:', archivo
        imprimir(data, lexer)	   
