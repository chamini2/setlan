#####################################################
#					Daniel Rodriguez				#
#						07-41475					#
#####################################################

#!usr/bin/env python
# -*- coding: utf-8 -*-

#####################################################
#  Importacion de modulos requeridos para el lexer  #
#####################################################

import sys
import lex

#####################################################
#	 	  Palabras reservadas del Programa 		    #
#####################################################
reserved = {
	# Programa
	'program' : 'PROGRAM',
	# Tipos
	'int' : 'INT',
	'bool' : 'BOOL',
	'set' : 'SET',
	# Booleanos
	'true' : 'TRUE',
	'false' : 'FALSE',
	# Bloques
	'using' : 'USING',
	'in' : 'IN',
	# Entrada
	'scan' : 'SCAN',
	# Salida
	'print' : 'PRINT',
	'println' : 'PRINTLN',
	# Condicionales
	'if' : 'IF',
	'then' : 'THEN',
	'else' : 'ELSE',
	# Iteracion
	'for' : 'FOR',
	'min' : 'MIN',
	'max' : 'MAX',
	# Iteracion Indeterminada
	'do' : 'DO',
	'while' : 'WHILE',
	'repeat' : 'REPEAT',
	# Operaciones Booleanas
	'or' : 'OR',
	'and' : 'AND',
	'not' : 'NOT',
}

#####################################################
#	 	 	 Tipos de Tokens del Programa 		    #
#####################################################
tokens = [
	"IDENTIFIER", "ASSIGN", "COMMA", "SEMICOLON", "LCURLY", "RCURLY", "PLUS", "MINUS", "TIMES", "DIVIDE", "MOD", "LPAREN", "RPAREN",
	"UNION", "DIFERENCE", "INTERSECTION", "ADDCONJUNCT", "SUBSTRACTCONJUNCT", "MULTIPLYCONJUNCT", "DIVIDECONJUNCT", "MODCONJUNCT", "MAXVALUE",
	"MINVALUE", "ELEMENTS", "LESS", "GREATER", "LTE", "GTE", "EQUALS", "NOTEQUAL", "AT", "STRING", "INTEGER"
] + list(reserved.values())

#####################################################
#   Ignoramos los espacios en blanco del Programa   #
#####################################################
t_ignore = ' \t'

#####################################################
#  Ignoramos las lineas de comentarios del Programa #
#####################################################
t_ignore_COMMENT = r'\#.*'

#####################################################
# Definimos los identificadores para que retornen	#
# el tipo IDENTIFIER si no es una palabra reservada #
#####################################################
def t_IDENTIFIER(t):
	r'[a-zA-Z_][a-zA-Z_0-9]*'
	t.type = reserved.get(t.value, 'IDENTIFIER')
	return t

#####################################################	
#	 Definimos la forma del resto de los Tokens		#
#####################################################
t_ASSIGN = r'='
t_COMMA = r','
t_SEMICOLON = r';'
t_LCURLY = r'{'
t_RCURLY = r'}'
t_PLUS = r'\+'
t_MINUS = r'-'
t_TIMES = r'\*'
t_DIVIDE = r'/'
t_MOD = r'%'
t_LPAREN = r'\('
t_RPAREN = r'\)'
t_UNION = r'\+\+'
t_INTERSECTION = r'><'
t_DIFERENCE = r'\\'
t_ADDCONJUNCT = r'<\+>'
t_SUBSTRACTCONJUNCT = r'<->'
t_MULTIPLYCONJUNCT = r'<\*>'
t_DIVIDECONJUNCT = r'</>'
t_MODCONJUNCT = r'<%>'
t_MAXVALUE = r'>\?'
t_MINVALUE = r'<\?'
t_ELEMENTS = r'\$\?'
t_LESS = r'<'
t_GREATER = r'>'
t_LTE = r'<='
t_GTE = r'>='
t_EQUALS = r'=='
t_NOTEQUAL = r'/='
t_AT = r'@'

#####################################################
# 			Definimos el valor de un Entero 		#
#####################################################
def t_INTEGER(t):
	r'\d+'
	t.value = int(t.value)
	return t

#####################################################
#	 		Definimos la forma de un STRING 		#
#####################################################
t_STRING = r'".*?"'

#####################################################
# 		Definimos el caracter de salto de linea 	#
#####################################################
def t_newline(t):
	r'\n+'
	t.lexer.lineno += t.value.count('\n')

#####################################################
# 		Creamos una lista de Errores en caso 		#
#			de que el Token sea invalido 			#
#####################################################
def t_error(t):
	syntax_errors.append("Error: Se encontr√≥ un caracter inesperado: '%s' en la linea %d, columna %d." % (t.value[0], t.lineno, columnNumber(lexer.lexdata, t)))
	t.lexer.skip(1)

#####################################################
# 		  Calculamos la columna en la cual 			#
# 				se encuentra el Error 				#
#####################################################
def columnNumber(program, token):
	line_start = program.rfind('\n',0,token.lexpos)
	if line_start < 0:
		line_start = -1
	column = token.lexpos - line_start
	return column
	
#####################################################
# 		Hacemos el chequeo lexico del programa		#
#		 Agregamos los Tokens si es correcto		#
#	  O imprimimos los errores si se encontraron	#
#####################################################
def syntaxCheck(file):

	global syntax_errors, lexer
	lexer = lex.lex()
	token_list = []
	syntax_errors = []
	lexer.input(file)

	for token in lexer:
		token_list.append(token)

	if not syntax_errors:
		return token_list
	else:
		for error in syntax_errors:
			print error
		return []

#####################################################
# 		Creamos el main para correr el Lexer 		#
#####################################################
def main(argv = None):
	
	if argv is None:
		argv = sys.argv
		
	if len(argv) == 1:
		print "Error: Introduzca un archivo para leer"
		return
		
	elif len(argv) > 2:
		print "Error: Introduzca SOLO 1 archivo para leer"
		return
	
	file = open(argv[1], 'r')

	token_list = syntaxCheck(file.read())
	
	for token in token_list:
		print 'Token ( %s )	 Valor: ( %s ) en la linea %s, columna %s' % (token.type, token.value, token.lineno, columnNumber(lexer.lexdata, token))

if __name__ == "__main__":
	main()