#!/usr/bin/env python
# -*- coding: utf-8 -*-

#Jesus Sanchez 10-10898
#Jose Barrientos 10-10800
#Entrega 3 ci-3725

import ply.lex as lex
import ply.yacc as yacc
import sys
import copy
from SymTable import *

#inicializacion de listas de tokens y errores encontrados
data =''
lexer_tokens = []
lista_aux = []
lexer_errores = []
errores=[]
parser=""
tabla= SymTable()

#lista de palabras reservadas
reserved = {
    'if' : 'IF',
    'else' : 'ELSE',
    'while' : 'WHILE',
    'do' : 'DO',
    'for' : 'FOR',
    'repeat' : 'REPEAT',
    'in' : 'IN',
    'program' : 'PROGRAM',
    'using' : 'USING',
    'set' : 'SET',
    'print' : 'PRINT',
    'println' : 'PRINTLN',
    'bool' : 'BOOL',
    'int' : 'INT',
    'scan' : 'SCAN',
    'not' : 'NOT',
    'and' : "AND",
    'or' : "OR",
    'min' : "MIN",
    'max' : "MAX"
}

#lista de tokens definidos
tokens = list(reserved.values()) + [

    'NUMERO','TRUE','FALSE','STRING','ID',
    'PLUS','MINUS','TIMES','DIVIDE','LPAREN','RPAREN',
    'SEMICOLON','EQUIV','ASIGNA','COMA','MODULE',
    'LESSTEQ','LESST','GREATEQ', 'GREATT','NOTEQ',
    'UNION', 'DIFERENCIA', 'INTERSECT', 'PLUSCONJ',
    'MINUSCONJ','TIMESCONJ', 'DIVCONJ','RESTOCONJ',
    'MAXCONJ', 'MINCONJ', 'SIZECONJ', 'CONTIENECONJ',
    'LLAVEIZ', 'LLAVEDE'

]

#expresiones regulares para atrapar tokens

t_PLUS    = r'\+'
t_MINUS   = r'-'
t_TIMES   = r'\*'
t_DIVIDE  = r'/'
t_LPAREN  = r'\('
t_RPAREN  = r'\)'
t_SEMICOLON = r';'
t_EQUIV = r'=='
t_ASIGNA = r'='
t_COMA = r','
t_MODULE = r'%'
t_LESSTEQ = r'<='
t_LESST = r'<'
t_GREATEQ = r'>='
t_GREATT = r'>'
t_NOTEQ = r'/='
t_UNION  = r'\+\+'
t_DIFERENCIA  = r'\\'
t_INTERSECT  = r'><'
t_PLUSCONJ  = r'<\+>'
t_MINUSCONJ  = r'<\->'
t_TIMESCONJ  = r'<\*>'
t_DIVCONJ  = r'</>'
t_RESTOCONJ  = r'<%>'
t_MAXCONJ  = r'>\?'
t_MINCONJ  = r'<\?'
t_SIZECONJ  = r'\$\?'
t_CONTIENECONJ  = r'@'
t_LLAVEIZ = r'{'
t_LLAVEDE = r'}'
t_ignore  = ' \t'

#funcion que identifica un token NUMERO y guarda su valor entero
def t_NUMERO(t):
    r'\d+'
    if((int(t.value)>2147483647) or (int(t.value)+ 2147483648)<0):
        print "El numero introducido excede 32 bits"
        exit(0)
    else:
        t.value = int(t.value)
    return t

#funcion que identifica un token TRUE y guarda su valor booleano
def t_TRUE(t):
    r'(\btrue\b)'
    t.value = "true"
    return t

#funcion que identifica un token FALSE y guarda su valor booleano
def t_FALSE(t):
    r'(\bfalse\b)'
    t.value = "false"
    return t

#funcion que identifica un token STRING y lo retorna
def t_STRING(t):
    r'\"([^\n\"\\]|\\n|\\"|\\\\)*\"'
    return t

#funcion que identifica un token ID para nombres de variables
def t_ID(t):
    r'[a-zA-Z_][a-zA-Z_0-9]*'
    t.type = reserved.get(t.value,'ID')
    return t

#metodo que identifica saltos de linea
def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

#metodo que identifica comentarios
def t_COMMENT(t):
    r'\#.*'

#funcion que calcula la columna de la palabra o simbolo que lee actualmente
def calcular_columna(input, tok):
    ultimo_salto = input.rfind('\n', 0, tok.lexpos)
    if ultimo_salto < 0:
        ultimo_salto = 0
    else:
        ultimo_salto += 1;
    columna = (tok.lexpos - ultimo_salto) + 1
    return columna

#metodo que almacena palabras o simbolos inesperadas en la lista de errores
def t_error(t):
    lexer_errores.append("Error: Se ha conseguido un caracter inesperado '%s' en linea %s, columna %s." %(t.value[0],t.lineno,str(calcular_columna(t.lexer.lexdata,t))))
    t.lexer.skip(1)


#metodo que almacena palabras o simbolos en la lista de tokens encontrados
def buscar(input, lexer):
    global lexer_tokens
    lexer.input(input)
    while True:
        tok = lexer.token()
        if not tok:
            break
        lexer_tokens.append(tok)

def recorrer(palabra):
    global lista_aux
    
    for x in lista_aux:
        
        if str(x.value) == str(palabra):
            lista_aux.remove(x)
            return x
        
def buscatipo(palabra):
    global tabla
    if (lexer.type == 'TRUE' or lexer.type=='FALSE'):
        return 'bool'
    elif (lexer.type=='NUMERO'):
        return 'int'
    elif (lexer.type=='ID'):
        aux = tabla.find(str(lexer.value))
        return aux.getTipo()
    else:
        return 'set'        

lexer = lex.lex()  

#################################################################################

indentar= ""
indentarbloque= ""

def agregar(indentar):
	return indentar+"\t"


def eliminar(indentar):
	return indentar[:-1]

class cnum:
    def __init__(self, numero):
        self.numero = numero
    def __str__(self):
        global indentar
        s= "CONSTANTE_ENT"
        indentar=agregar(indentar)
        s=s+"\n"+indentar+"valor: "+str(self.numero)
        indentar=eliminar(indentar)
        return s+"&"+str(self.numero)+"&int"

class cbool:
    def __init__(self, boo):
        self.boo = boo
    def __str__(self):
        global indentar
        s= "CONSTANTE_BOOL"
        indentar=agregar(indentar)
        s=s+"\n"+indentar+"valor: "+str(self.boo)
        indentar=eliminar(indentar)
        return s+"&"+str(self.boo)+"&bool"

class variable:
    def __init__(self, ident):
        self.ident = ident
    def __str__(self):
        global indentar
        global tabla
        global data
        global errores
        tipo= 'unknow'
        s=""
        help=recorrer(self.ident)
        indentar=agregar(indentar)
        if tabla.hay_iter():
            if (tabla.isMember(self.ident)):
                aux=tabla.find(self.ident)
                tipo= aux.getTipo()
            elif (tabla.aux_isMember(self.ident)):
                aux=tabla.aux_find(self.ident)
                tipo= aux.getTipo()
            else:
                
                errores.append("Error en la linea '%s', columna '%s': no puede usar la variable '%s' pues no ha sido declarada"%(help.lineno,str(calcular_columna(data,help)),self.ident))
        else:       
            
            if not(tabla.isMember(self.ident)):
                
                errores.append("Error en la linea '%s', columna '%s': no puede usar la variable '%s' pues no ha sido declarada"%(help.lineno,str(calcular_columna(data,help)),self.ident))
            else:
                aux=tabla.find(self.ident)
                tipo= aux.getTipo()
        s = "VARIABLE \n"+indentar+"nombre: "+str(self.ident)
        indentar=eliminar(indentar)
        return s+"&"+str(self.ident)+"&"+tipo

class unario:
    def __init__(self,oper,ident):
        self.oper = oper
        self.ident = ident
    def __str__(self):
        global indentar
        global tabla
        global data
        global errores
        help=recorrer(self.oper)
        t=''
        extra= str(self.ident).split("&")
        tipo= extra[2]
        expr= extra[1]
        
        if(self.oper=='-' and tipo != 'int'):
            errores.append("Error en la linea '%s', columna '%s': intento de aplicar \"menos unario\" a '%s' de tipo '%s' "%(help.lineno,str(calcular_columna(data,help)),str(expr),tipo))
           
        elif(self.oper=='-' and tipo == 'int'):
            t = 'menos unario'
            
        if(self.oper=='not' and tipo != 'bool'):
            errores.append("Error en la linea '%s', columna '%s': intento de aplicar \"not\" a variable '%s' de tipo '%s' "%(help.lineno,str(calcular_columna(help.lexer.lexdata,help)),str(expr),tipo))
        elif(self.oper=='not' and tipo == 'bool'):
            t = 'not'
            
        if((self.oper=='>?' or self.oper=='<?' or self.oper=='$?') and tipo != 'set'):
            errores.append("Error en la linea '%s', columna '%s': intento de aplicar '%s' a variable '%s' de tipo '%s' "%(help.lineno,str(calcular_columna(data,help)),str(self.oper),str(expr),tipo))
        elif((self.oper=='>?' or self.oper=='<?' or self.oper=='$?') and tipo == 'set'):
            t = self.oper
            
        indentar=agregar(indentar)
        if not(self.oper=='>?' or self.oper=='<?' or self.oper=='$?'):
            
            s= "EXPRESION_UN\n"+indentar+"operador: "+str(t)+"\n"+indentar+"operando: "+str(extra[0])
            indentar=eliminar(indentar)
            return s+"&"+str(self.oper)+expr+"&"+tipo
        
        else:
            s= "EXPRESION_UN\n"+indentar+"operador: "+str(t)+"\n"+indentar+"operando: "+str(extra[0])
            indentar=eliminar(indentar)
            return s+"&"+str(self.oper)+expr+"&"+'int'

class binario:
    def __init__(self,prim,oper,seg):
        self.prim = prim
        self.oper = oper
        self.seg = seg
    
    def __str__(self):
        global indentar
        global tabla
        global data
        global errores
        op=''
        if(self.oper=='+'):
            op='mas'
        elif(self.oper=='-'):
            op='resta'
        elif(self.oper=='*'):
            op='por'
        elif(self.oper=='/'):
            op='division'
        elif(self.oper=='%'):
            op='modulo'
        elif(self.oper=='<'):
            op='menor que'
        elif(self.oper=='>'):
            op='mayor que'
        elif(self.oper=='<='):
            op='menor o igual que'
        elif(self.oper=='>='):
            op='mayor o igual que'
        elif(self.oper=='=='):
            op='equivalente'
        elif(self.oper=='/='):
            op='no igual a'
        elif(self.oper=='><'):
            op='interseccion'
        elif(self.oper=='++'):
            op='union'
        elif(self.oper=='<+>'):
            op='suma mapeada'
        elif(self.oper=='<->'):
            op='resta mapeada'
        elif(self.oper=='<*>'):
            op='multiplicacion mapeada'
        elif(self.oper=='</>'):
            op='division mapeada'
        elif(self.oper=='<%>'):
            op='resto division mapeada'
        elif(self.oper=='@'):
            op='contencion conjunto'
        elif(self.oper=='or'):
            op='or'
        elif(self.oper=='and'):
            op = 'and'
        else:
            op = 'diferencia'
        final='unknow'
        help=recorrer(self.oper)
        extra1= str(self.prim).split("&")
        tipo1= extra1[2]
        expr1= extra1[1]
        extra2= str(self.seg).split("&")
        tipo2= extra2[2]
        expr2= extra2[1]
        
        if ((self.oper=='+' or self.oper=='-' or self.oper =='*' or self.oper =='/' or self.oper =='%') and (tipo1 != 'int' or tipo2 != 'int')) or\
           ((self.oper=='and' or self.oper=='or') and (tipo1 != 'bool' or tipo2 != 'bool')) or\
           ((self.oper=='<' or self.oper=='<=' or self.oper=='>' or self.oper=='>=' or self.oper=='==' or self.oper=='/=') and\
           ((tipo1 != 'int' or tipo2 != 'int'))):
            errores.append("Error en la linea '%s', columna '%s': intento de aplicar \"%s\" a '%s' de tipo '%s' con '%s' de tipo '%s' "%\
                          (help.lineno,str(calcular_columna(data,help)),op,str(expr1),str(tipo1),str(expr2),str(tipo2)))
                      
        elif ((self.oper=='-' or self.oper=='/' or self.oper =='%' or self.oper=='+' or self.oper=='*') and (tipo1 == 'int' and tipo2 == 'int') ):
            final='int'
        
        elif ((self.oper=='++' or self.oper=='\\' or self.oper=='><') and (tipo1=='set' and tipo2=='set')) or\
             ((self.oper=='<+>' or self.oper=='<->' or self.oper=='<*>' or self.oper=='</>' or self.oper=='<%>') and\
             ((tipo1=='int' and tipo2=='set') or (tipo2=='int' and tipo1=='set'))):
            final='set'
        
        elif ((self.oper=='and' or self.oper=='or') and (tipo1 == 'bool' and tipo2 == 'bool')) or\
             ((self.oper=='@') and (tipo1 == 'int' and tipo2 == 'set')) or\
             ((self.oper=='<' or self.oper=='<=' or self.oper=='>' or self.oper=='>=' or self.oper=='==' or self.oper=='/=') and (tipo1 == 'int' and tipo2 == 'int')):
            final='bool'
            
        indentar=agregar(indentar)
        s= "EXPRESION_BIN\n"+indentar+"operador: "+op+"\n"+indentar+"operando izq: "+str(extra1[0])+"\n"+indentar+"operando der: "+str(extra2[0])
        indentar=eliminar(indentar)
        return s+'&'+expr1+str(self.oper)+expr2+'&'+final

class elemconj:
    def __init__(self,num,val):
        self.num = num
        self.val = val
    def __str__(self):
        global indentar
        s=str(self.num)+"\n"+indentar+str(self.val)
        return s
  
class conjunto:
    def __init__(self,nom):
        self.nom = nom
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= "CONJUNTO\n"+indentar+"MIEMBROS: \n"+indentar+str(self.nom)+"\n"+indentar
        indentar=eliminar(indentar)
        return s+"&"+str(self.nom)+"&set"

class separa:
    def __init__(self,val1,val2):
        self.val1 = val1
        self.val2 = val2
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= indentar+""+str(self.val1)+"\n"+indentar+"SEPARADOR"
        indentar=eliminar(indentar)
        z= recorrer(";")
        s=s+"\n"+str(self.val2)
        return s

class chain:
    def __init__(self,nom):
        self.nom = nom
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= "CADENA\n"+indentar+"valor: "+str(self.nom)
        indentar=eliminar(indentar)
        return s
      
class lectura:
    def __init__(self,nom):
        self.nom = nom
    def __str__(self):
        global indentar
        global tabla
        global errores
        help=recorrer(self.nom)
        
        s= "SCAN"
        if not(tabla.isMember(self.nom)):
            errores.append("Error en la linea '%s', columna '%s': no puede usar la variable '%s' pues no ha sido declarada"%\
                          (help.lineno,str(calcular_columna(help.lexer.lexdata,help)),self.nom))
        else:
            symbol=tabla.find(self.nom)
            sym= symbol.getTipo()
            
            if(sym=='int' or sym=='bool'):
                indentar=agregar(indentar)
                s= s+"\n"+indentar+"variable: "+str(self.nom)
                indentar=eliminar(indentar)
                
            else:
                errores.append("Error en la linea '%s', columna '%s': no puede escanear a la variable '%s' por ser de tipo '%s'"%\
                              (help.lineno,str(calcular_columna(help.lexer.lexdata,help)),self.nom,sym))
        return s

class escritura:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        if (str(self.nom)=='print'):
            s= str(self.nom).upper()+"\n"
            s= s+""+indentar+"elemento: "+str(self.val)
        else:
            s= "PRINT\n"
            s= s+""+indentar+"elemento: "+str(self.val)
            s= s+"\n"+indentar+"elemento: CADENA"
            indentar=agregar(indentar)
            s= s+"\n"+indentar+"valor: \\n"
            indentar=eliminar(indentar)
        indentar=eliminar(indentar)
        return s

class inicio:
    def __init__(self,nom):
        self.nom = nom
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= "\n"+"PROGRAM"+"\n"+indentar+str(self.nom)
        indentar=eliminar(indentar)
        return s
      
class inicializar:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        if (self.val!=""):
            s= indentar+"USING: "
            indentar=agregar(indentar)
            s= s+str(self.nom)
            indentar=eliminar(indentar)
            s= s+"\n"+indentar+"IN: "+"\n"+str(self.val)
        else:
            s= indentar+str(self.nom)
        indentar=eliminar(indentar)
        return s

class ausar:
    def __init__(self,nom,val):
       self.nom = nom
       self.val = val
    def __str__(self):
        global indentar

        if (self.val!=""):
            s= str(self.nom)+str(self.val)
        else:
            s=str(self.nom)   
        return s
      
class diferenciar:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        s="\n"+indentar+str(self.nom)+" "+str(self.val)
        return s

class organizar:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        s=str(self.nom)+str(self.val)
        return s	      

class sonvarios:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        s= str(self.nom)+", "+str(self.val)   
        return s

class bloque:
    def __init__(self,nom):
        self.nom = nom
    def __str__(self):
        global indentar
        global tabla
        tmpTabla= SymTable()
        tabla.insert('1', tmpTabla)
        indentarbloque = indentar
        s= "BLOQUE"
        s= s+"\n"+str(self.nom)
        s= s+"\n"+indentarbloque+"FINAL DEL BLOQUE"
        tabla.delete()
        return s

class asignacion:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        global tabla
        global errores
        ayuda= str(self.val).split('&')
        expr=ayuda[0]
        s= "ASIGNACION"
        help=recorrer(self.nom)
        if tabla.hay_iter():
            if (tabla.aux_isMember(self.nom)):#hay iteracion y es miembro de la tabla q lleva los for
                
                errores.append("Error en la linea \"%s\", columna \"%s\": se intenta modificar la variable \"%s\" la cual pertenece a una iteracion"%(help.lineno,str(calcular_columna(help.lexer.lexdata,help)),self.nom))
            elif not(tabla.isMember(self.nom)):#hay iter y no esta ni en la tabla de los fors ni en la de los bloques
                
                errores.append("Error en la linea '%s', columna '%s': no puede usar la variable '%s' pues no ha sido declarada"%(help.lineno,str(calcular_columna(help.lexer.lexdata,help)),self.nom))
            
            else:
                symbol=tabla.find(self.nom)
                sym= symbol.getTipo()
                if ayuda[2] != sym:
                    errores.append("Error en la linea '%s', columna '%s': no puede asignar a la variable '%s' de tipo '%s' el valor '%s' de tipo '%s' "%(help.lineno,str(calcular_columna(help.lexer.lexdata,help)),self.nom,str(sym),str(ayuda[1]),str(ayuda[2]))) 
                
                else:
                    indentar=agregar(indentar)
                    s= s+"\n"+indentar+"var: "+str(self.nom)+"\n"+indentar+"val: "+expr
                    indentar=eliminar(indentar)     
        else:
            
            if not(tabla.isMember(self.nom)):
                errores.append("Error en la linea '%s', columna '%s': no puede usar la variable '%s' pues no ha sido declarada"%(help.lineno,str(calcular_columna(help.lexer.lexdata,help)),self.nom))
            else: 
                symbol=tabla.find(self.nom)
                sym= symbol.getTipo()
                if ayuda[-1] != sym:
                    errores.append("Error en la linea '%s', columna '%s': no puede 9asignar a la variable '%s' de tipo '%s' el valor '%s' de tipo '%s' "%(help.lineno,str(calcular_columna(help.lexer.lexdata,help)),self.nom,str(sym),str(ayuda[1]),str(ayuda[-1])))
                if (sym=='set' and len(ayuda)>3):
                    indentar=agregar(indentar)
                    j=0
                    for i in range(0, len(ayuda)/4):
                        s= s+"\n"+indentar+"var: "+str(self.nom)+"\n"+indentar+"val: "+ayuda[j]
                        j=j+2
                    indentar=eliminar(indentar)
                else:
                    indentar=agregar(indentar)
                    s= s+"\n"+indentar+"var: "+str(self.nom)+"\n"+indentar+"val: "+expr
                    indentar=eliminar(indentar)
        return s

class condicional:
    def __init__(self,nom,val,otro):
        self.nom = nom
        self.val = val
        self.otro = otro
    def __str__(self):
        global indentar
        global errores
        s= "CONDICIONAL"
        help= recorrer('if')
        extra= str(self.nom).split("&")
        tipo= extra[2]
        expr= extra[1]
        
        if tipo!='bool':
            errores.append("Error en la linea '%s', columna '%s': la expresion'%s' de tipo '%s' no es condicion valida para if"%(help.lineno,str(calcular_columna(data,help)),str(expr),str(tipo)))         
        
        indentar=agregar(indentar)
        if (self.otro!=""):
            s= s+"\n"+indentar+"condicion: "+str(extra[0])+"\n"+indentar+"eval_true: "+str(self.val)+"\n"+indentar+"eval_false: "+str(self.otro)
        else:
            s= s+"\n"+indentar+"condicion: "+str(extra[0])+"\n"+indentar+"eval_true: "+str(self.val)
        indentar=eliminar(indentar)
        return s

class iterindet:
    def __init__(self,nom,val,otro):
        self.nom = nom
        self.val = val
        self.otro = otro
    def __str__(self):
        global indentar
        global errores
        help=recorrer('while')
        s= "ITERACION_INDET"
        extra= str(self.val).split("&")
        tipo= extra[-1]
        expr= extra[1]
        
        if tipo!='bool':
            errores.append("Error en la linea '%s', columna '%s': la expresion'%s' de tipo '%s' no es condicion valida para while"%(help.lineno,str(calcular_columna(data,help)),str(expr),str(tipo)))          
 
        elif(self.otro!=""):
            indentar=agregar(indentar)
            s= s+"\n"+indentar+"instruccion 1: "
            indentar=agregar(indentar)
            s= s+"\n"+indentar+str(self.nom)
            indentar=eliminar(indentar)
            s= s+"\n"+indentar+"condicion: "+str(self.val)+"\n"+indentar+"instruccion 2: "
            indentar=agregar(indentar)
            s= s+"\n"+indentar+str(self.otro)
            indentar=eliminar(indentar)
        else:
            indentar=agregar(indentar)
            s= s+"\n"+indentar+"condicion: "+str(self.val)+"\n"+indentar+"instruccion: "
            indentar=agregar(indentar)
            s= s+"\n"+indentar+str(self.nom)
            indentar=eliminar(indentar)
        
        return s

class iterdet:
    def __init__(self,nom,direc,val,foo):
        self.nom = nom
        self.direc = direc
        self.val = val
        self.foo = foo
    def __str__(self):
        global indentar
        global tabla
        global errores
        help= recorrer('for')
        extra= str(self.val).split("&")
        tipo= extra[-1]
        expr= extra[1]
        division = 4
        
        if tipo!='set':
            errores.append("Error en la linea '%s', columna '%s': la expresion'%s' de tipo '%s' no es rango valido para for, debe ser de tipo 'set'"%(help.lineno,str(calcular_columna(data,help)),str(expr),str(tipo)))
        help=recorrer(self.nom)
        tmpTabla=SymTable()
        tabla.aux_insert('2',tmpTabla)
        a= Atributos('int','5')
        tabla.aux_insert(self.nom,a)
        
        s= "ITERACION_DET"
        indentar=agregar(indentar)
        s= s+"\n"+indentar+"variable: "+str(self.nom)+"\n"+indentar+"direccion: "+str(self.direc)+"\n"+indentar+"rango: "
        j=0
        for i in range(0, len(extra)/division):
            s= s+str(extra[j]).lstrip("int")
            j=j+2
        s=s+"\n"+indentar+"instruccion: "    
        indentar=agregar(indentar)
        s= s+"\n"+indentar+str(self.foo)
        indentar=eliminar(indentar)
        indentar=eliminar(indentar)
        tabla.aux_delete()
        return s

class auxiliar:
    def __init__(self,nom):
        self.nom= nom
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= indentar+""+str(self.nom)
        return s
    
class escribeuno:
    def __init__(self,nom):
        self.nom= nom
    def __str__(self):
        global indentar
        extra= str(self.nom).split("&")
        s= str(extra[0])+"\n"+indentar
        return s
    
class escribedos:
    def __init__(self,nom,val):
        self.nom= nom
        self.val= val
    def __str__(self):
        global indentar
        help=recorrer(",")
        extra= str(self.nom).split("&")
        extra2= str(self.val).split("&")
        s= str(extra[0])+"\n"+indentar
        s= s+ "elemento: "+str(extra2[0])
        return s

#################################################################################

class declaro_una:
    def __init__(self,clave,tipo):
        self.clave= clave
        self.tipo= tipo
    def __str__(self):
        global tabla
        global indentar
        global errores
        a= Atributos(str(self.tipo),"")
        global lista_aux
        help=recorrer(self.clave)
        if not(tabla.deepestMember(self.clave)):
            tabla.insert(self.clave,a)
        else:
            errores.append("Error en la linea '%s', columna '%s': la variable '%s' ya ha sido declarada"%(help.lineno,str(calcular_columna(help.lexer.lexdata,help)),self.clave))
        s= tabla.__str__(indentar)
        return s
        
class hacertabla:
    def __init__(self,variables,instrucciones):
        self.variables=variables
        self.instrucciones=instrucciones
    def __str__(self):
        global indentar

        indentar=agregar(indentar)
        s= indentar+"SCOPE\n"
        s= s+str(self.variables)+"\n"
        indentar= eliminar(indentar)
        s= s+str(self.instrucciones)
        return s

class declaro_muchas:
    def __init__(self,claves,tipo):
        self.claves=claves
        self.tipo=tipo
    def __str__(self):
        global tabla
        global lista_aux
        global errores
        aux=str(self.claves).split(",")
        a=Atributos(str(self.tipo),"")
        for x in aux:
            help=recorrer(x)
            if not(tabla.deepestMember(x)):
                tabla.insert(x,a)
            else:
                errores.append("Error en la linea '%s', columna '%s': la variable '%s' ya ha sido declarada"%(help.lineno,str(calcular_columna(help.lexer.lexdata,help)),x)) 
        s= tabla.__str__(indentar)
        return s

class enlistar_var:
    def __init__(self,ident,otro):
        self.ident=ident
        self.otro=otro
    def __str__(self):
        return str(self.ident)+","+str(self.otro)

class multi:
    def __init__(self,claves,tipos,mas):
        self.claves=claves
        self.tipos=tipos
        self.mas=mas
    def __str__(self):
        aux= str(declaro_muchas(self.claves,self.tipos))
        return str(self.mas)

class simple:
    def __init__(self,claves,tipos,mas):
        self.claves=claves
        self.tipos=tipos
        self.mas=mas
    def __str__(self):
        aux= str(declaro_una(self.claves,self.tipos))
        return str(self.mas)





#################################################################################
start = 'program'

precedence = ( 
    ('left','OR'),
    ('left','AND'),
    ('right','NOT'),
    ('nonassoc','LESST','LESSTEQ','GREATT','GREATEQ'),
    ('nonassoc','NOTEQ','EQUIV'),
    ('nonassoc','CONTIENECONJ'),
    ('left','PLUS','MINUS'),
    ('left','TIMES','DIVIDE','MODULE'),
    ('left','PLUSCONJ','MINUSCONJ'),
    ('left','TIMESCONJ','DIVCONJ','RESTOCONJ'),
    ('left','UNION','DIFERENCIA'),
    ('left','INTERSECT'),
    ('right','UMINUS','MAXCONJ','MINCONJ','SIZECONJ'),
    ('nonassoc','LPAREN','RPAREN')
)

#Gramatica
#principal
def p_prog(p): 
    'program : PROGRAM instruccion'
    p[0]= inicio(p[2])

# Variables a declarar
def p_vars(p):
    '''vars : INT ID SEMICOLON
        | SET ID SEMICOLON
        | BOOL ID SEMICOLON
        | INT ID asTipo
        | SET ID asTipo
        | BOOL ID asTipo'''
    if (p[3]==';'):
        p[0]=declaro_una(p[2],p[1])
    else:
        p[0]=simple(p[2],p[1],p[3])
        

def p_vars2(p):
    '''vars : INT varios SEMICOLON
        | BOOL varios SEMICOLON
        | SET varios SEMICOLON
        | INT varios asTipo
        | BOOL varios asTipo
        | SET varios asTipo'''     
    if (p[3]==';'):
        p[0]=declaro_muchas(p[2],p[1])
    else:
        p[0]=multi(p[2],p[1],p[3])


# Tipo de variables declaradas
def p_asTipo(p):
    'asTipo : SEMICOLON vars'
    p[0]=p[2]

#Secuencia de elementos separados por coma      
def p_varios(p):
    'varios : ID COMA ID'
    p[0]=enlistar_var(p[1],p[3])

def p_varios2(p):
    'varios : ID COMA varios'   
    p[0]=enlistar_var(p[1],p[3])

#Expresiones binarias, constantes,variables, unarios y funciones incluyendo parentesis
def p_expBinUnFun(p): 
    '''expBinUnFun : LPAREN expBinUnFun RPAREN
        | expBinUnFun TIMES expBinUnFun
        | expBinUnFun DIVIDE expBinUnFun
        | expBinUnFun MODULE expBinUnFun
        | expBinUnFun PLUS expBinUnFun
        | expBinUnFun MINUS expBinUnFun
        | expBinUnFun LESSTEQ expBinUnFun
        | expBinUnFun LESST expBinUnFun
        | expBinUnFun GREATEQ expBinUnFun
        | expBinUnFun GREATT expBinUnFun
        | expBinUnFun EQUIV expBinUnFun
        | expBinUnFun NOTEQ expBinUnFun
        | expBinUnFun AND expBinUnFun
        | expBinUnFun OR expBinUnFun
        | expBinUnFun UNION expBinUnFun
        | expBinUnFun INTERSECT expBinUnFun
        | expBinUnFun DIFERENCIA expBinUnFun
        | expBinUnFun CONTIENECONJ expBinUnFun
        | expBinUnFun PLUSCONJ expBinUnFun
        | expBinUnFun MINUSCONJ expBinUnFun
        | expBinUnFun TIMESCONJ expBinUnFun
        | expBinUnFun DIVCONJ expBinUnFun
        | expBinUnFun RESTOCONJ expBinUnFun
        | MINUS expBinUnFun %prec UMINUS
        | LLAVEIZ elementosconj LLAVEDE
        | NOT expBinUnFun
        | MAXCONJ expBinUnFun
        | MINCONJ expBinUnFun
        | SIZECONJ expBinUnFun
        | NUMERO 
        | TRUE 
        | FALSE
        | ID'''

    if(len(p)==2):
        aux=""
        aux2=[]
        if(str(p[1]).isdigit()):
            p[0]= cnum(p[1])
        elif(p[1]=='true' or p[1]=='false'):
            p[0]= cbool(p[1])
        else:
            p[0]= variable(p[1])
    elif(len(p)==3):
        p[0]= unario(p[1],p[2])
    elif(len(p)==4):
        if(p[3]==')'):
            p[0]= p[2]
        elif(p[1]=='{'):
            p[0]= conjunto(p[2])
        else:
            p[0]= binario(p[1],p[2],p[3])

# Regla para trabajar elementos sobre conjunto
def p_elementosconj(p):
    ''' elementosconj : expBinUnFun COMA elementosconj
        | expBinUnFun
        | ''' # Vacio
    if(len(p)==1):
        p[0]= "Vacio"
    elif(len(p)==2):
        p[0]= p[1]
    else:
        p[0]= elemconj(p[1],p[3])

# Operacion string a imprimir uno o varios
def p_aImprimir(p):
    ''' aImprimir : expBinUnFun COMA aImprimir
        | expBinUnFun 
        | cadena COMA aImprimir
        | cadena'''
    if(len(p)==2):
        p[0]= escribeuno(p[1])
    else:
        p[0]= escribedos(p[1],p[3])

# Instrucciones
def p_instruccion(p):
    ''' instruccion : LLAVEIZ DeclaracionInstrucion LLAVEDE
        | ID ASIGNA expBinUnFun
        | SCAN ID
        | PRINTLN aImprimir
        | PRINT aImprimir
        | IF LPAREN expBinUnFun RPAREN instruccion ELSE instruccion
        | IF LPAREN expBinUnFun RPAREN instruccion
        | FOR ID MIN expBinUnFun DO instruccion
        | FOR ID MAX expBinUnFun DO instruccion
        | REPEAT instruccion WHILE LPAREN expBinUnFun RPAREN DO instruccion
        | WHILE LPAREN expBinUnFun RPAREN DO instruccion
        | REPEAT instruccion WHILE LPAREN expBinUnFun RPAREN'''

    if(len(p)==3):
        if(p[1]=='scan'):
            p[0]= lectura(p[2])
        else:
            p[0]= escritura(p[1],p[2])
    elif(len(p)==4):
        if(p[1]=='{'):
            p[0]= bloque(p[2])
        else:
            p[0]= asignacion(p[1],p[3])
    elif(len(p)==6):	
        p[0]= condicional(p[3],p[5],"")
    elif(len(p)==7):
        if(p[1]=='for'):
            p[0]= iterdet(p[2],p[3],p[4],p[6])
        elif(p[1]=='repeat'):
            p[0]= iterindet(p[2],p[5],"")
        else:
            p[0]= iterindet(p[6],p[3],"")
    elif(len(p)==8):
        p[0]= condicional(p[3],p[5], p[7])
    else:
        p[0]= iterindet(p[2],p[5],p[8])

# Instrucciones internas
def p_variasInstr(p):
    ''' variasInstr : instruccion SEMICOLON variasInstr
        | instruccion SEMICOLON'''
    if(len(p)==4):
        p[0]= separa(p[1],p[3])
    else:
        p[0]= auxiliar(p[1])    

#Declaracion de variables
def p_DeclaracionInstrucion(p):
    ''' DeclaracionInstrucion : USING vars IN variasInstr
        | variasInstr
        | USING vars IN
        | ''' #Vacio
    if(len(p)==1):
        p[0]=inicializar("","")
    elif(len(p)==2):
        p[0]=p[1]
    elif(len(p)==5):
        p[0]=hacertabla(p[2],p[4])

#Cadena
def p_cadena(p):
    'cadena : STRING'
    p[0]= chain(p[1])

#Permite la deteccion de errores y detencion del programa cuando esto sucede	
def p_error(p):
    if( p is None ):
        print "Error de sintaxis al final del archivo"	
    else:
        print "Error de sintaxis en linea '%s', columna '%s': token '%s' inesperado"%(str(p.lineno),str(calcular_columna(p.lexer.lexdata,p)),str(p.value))
    sys.exit(0)

def imprimir(input, lexer):
    buscar(input, lexer)
    if len(lexer_errores) > 0:
        for tok in lexer_errores:
            print(tok)
    else:
        for tok in lexer_tokens:
            if(tok.type=='ID' or tok.type=='STRING' or tok.type=='NUMBER'):
                if(tok.type=='STRING'):
                    print "Tk%s %s (Linea %s, Columna %s)" % (tok.type, tok.value, tok.lineno,str(calcular_columna(input,tok)))
                else:   
                    print "Tk%s \"%s\" (Linea %s, Columna %s)" % (tok.type, tok.value, tok.lineno,str(calcular_columna(input,tok)))

            else:
                print "Tk%s (Linea %s, Columna %s)" % (tok.type,tok.lineno,str(calcular_columna(input,tok)))    
lexer = lex.lex()
#################################################################################

#Principal
if __name__ == '__main__':
    if(len(sys.argv) <= 2):
        print "Falta al menos un argumento. \nDebe ser: ./setlan Archivo.extension -accion\nDonde accion puede ser: '-s' o '-t' tantas veces como desee"
    else:
        archivo = sys.argv[1]
        data=""
        try:
            fh = open(archivo, 'r')
            data = fh.read()
            fh.close()
        except IOError:
            print 'No se puede abrir el archivo:', archivo
        
        tam = len(sys.argv)
        
        for i in range(2,tam):
            accion = sys.argv[i]
            indentar= ""
            indentarbloque= ""
            
            if (accion=='-s'):
                buscar(data, lexer)
                if len(lexer_errores) > 0:
                    for tok in lexer_errores:
                        print(tok)
                else:
                    lista_aux = lexer_tokens
                    lexer.lineno=1
                    parser = yacc.yacc()
                    arbol = parser.parse(data)
                    a_arbol=str(arbol)
                    if not errores:
                        print a_arbol
                    else:   
                        for x in errores:
                            print x
                        
            elif (accion=='-t'):
                print"\n"
                imprimir(data, lexer)
                
            elif (accion=='-a'):
                buscar(data, lexer)
                if len(lexer_errores) > 0:
                    for tok in lexer_errores:
                        print(tok)
                else:
                    lista_aux = lexer_tokens
                    lexer.lineno=1
                    parser = yacc.yacc()
                    arbol = parser.parse(data)
                    a_arbol=str(arbol)
                    if not errores:
                        print a_arbol
                    else:   
                        for x in errores:
                            print x
                            
            else:
                print "Accion no permitida, recuerde que la ejecucion\ndebe ser: ./setlan Archivo.extension -accion\nDonde accion puede ser: '-s' o '-t' tantas veces como desee"
                