#! /usr/bin/env python

import re
import os
import sys
from   clases import*
import ply.lex as lex
import ply.yacc as yacc

# Proyecto 2.
# Tradutores
# Grupo 16
# Betzabeh Gonzalez Canonico: 08-10462
# Andel Nunez 08-10804

         #Setlan

#Palabras reservadas del lenguaje
reservadas = {

    #Inicio de Programa
    'program' :'TokenProgram',

    #Entrada y salida de datos
    'scan'    :'TokenScan',
	'print'   :'TokenPrint',
    'println' :'TokenPrintln',

    #Bloques
    'using'   :'TokenUsing',
    'in'      :'TokenIn',

    #Instrucciones condicionales
    'if'      :'TokenIf',
    'else'    :'TokenElse',

    #Iteracion determinada
    'for'     :'TokenFor',
	'do'      :'TokenDo',

    #Iteracion indeterminada
    'while'   :'TokenWhile',
    'repeat'  :'TokenRepeat',

    #Tipos de datos
       #Enteros
    'int'     :'TokenInt',
       #Booleanos
    'bool'    :'TokenBool',
       #Conjuntos
    'set'     :'TokenSet',
    'min'     :'TokenMin',
    'max'     :'TokenMax',

    #Operadores con booleanos
    'true'    :'TokenTrue',
    'false'   :'TokenFalse',
    'and'     :'TokenAnd',
    'or'      :'TokenOr',
    'not'     :'TokenNot',

    }

#################################
#       Lista de Tokens         #
#################################

tokens = [

    #Identificador de Variables
    'TokenIdent',

   	#Tipos
	'TokenNum',

    #Operadores aritmeticos
	'TokenMult',
    'TokenDivision',
	'TokenResto',
	'TokenSuma',
	'TokenResta',

    #Operadores de Conjuntos
	'TokenUnion',
	'TokenDiferencia',
	'TokenInterseccion',
	'TokenSumaCjto',
    'TokenRestaCjto',
    'TokenMultCjto',
    'TokenDivisionCjto',
    'TokenRestoCjto',
    'TokenMaxValorCjto',
    'TokenMinValorCjto',
    'TokenNumElemCjto',

    #Operadores logicos
    'TokenContenCjto',
	'TokenIgual',
    'TokenDesigual',
	'TokenMenor',
	'TokenMenorIgual',
	'TokenMayor',
	'TokenMayorIgual',

	#Separador de instrucciones
    'TokenPuntoYComa',
	'TokenParAbre',
	'TokenParCierra',
	'TokenComa',
	'TokenAsignacion',
    'TokenLlaveAbre',
  	'TokenLlaveCier',

	#String
    'TokenString'
] + list(reservadas.values())

#######################################
#   Expresiones Regulares Simples     #
#######################################

#Separador de instrucciones
t_TokenPuntoYComa   = r'\;'
t_TokenParAbre      = r'\('
t_TokenParCierra    = r'\)'
t_TokenComa         = r'\,'
t_TokenAsignacion   = r'\='
t_TokenLlaveAbre    = r'\{'
t_TokenLlaveCier    = r'\}'

#Operadores de Conjuntos
t_TokenUnion        = r'\+\+'
t_TokenDiferencia   = r'\\'
t_TokenInterseccion = r'\>\<'
t_TokenSumaCjto     = r'\<\+\>'
t_TokenRestaCjto    = r'\<\-\>'
t_TokenMultCjto     = r'\<\*\>'
t_TokenDivisionCjto = r'\<\/\>'
t_TokenRestoCjto    = r'\<\%\>'
t_TokenMaxValorCjto = r'\>\?'
t_TokenMinValorCjto = r'\<\?'
t_TokenNumElemCjto  = r'\&\?'

#Operadores con enteros
t_TokenMult         = r'\*'
t_TokenDivision     = r'\/'
t_TokenResto        = r'\%'
t_TokenSuma         = r'\+'
t_TokenResta        = r'\-'

#Operadores logicos
t_TokenIgual      = r'\=\='
t_TokenDesigual   = r'\/\='
t_TokenMenor      = r'\<'
t_TokenMayor      = r'\>'
t_TokenMenorIgual = r'\<\='
t_TokenMayorIgual = r'\>\='
t_TokenContenCjto = r'\@'


##############################
#       Identificadores      #
##############################

# Identificador de variables
def t_TokenIdent(t):
    r'[a-zA-Z_][\w]*'
    t.type = reservadas.get(t.value,'TokenIdent')
    return t

# Identificador literales numericos
def t_TokenNum(t):
    r'([-]?(\d+))'
    return t

# Identificador para los literales de print
def t_TokenString(t):
    r'\"[\w|\W|\s]*\"'
    return t

# Comentarios
def t_comment(t):
	r'\#.*'
	t.lexer.lineno += t.value.count('\n')

# Numeros de lineas
def t_TokenLinea(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

# Errores
def t_error(t):
    t.value= "Error: Se encontro caracter inesperado \"%s\" %s %d %s %d " %( t.value[0],"en linea",t.lineno,", columna ",t.lexpos+1)
    t.lexer.skip(1)
    return t

# Ignora espacios en blanco
t_ignore = ' \t'

###############################
#    Analizador sintactico    #
###############################

# Precedencia
precedence = (
           #Operadores logicos
           ('left','TokenOr'),
           ('left','TokenAnd'),
           ('nonassoc','TokenTrue','TokenFalse'),
           ('left','TokenNot'),

           #Operadores comparativos
	       ('left','TokenMenor','TokenMenorIgual','TokenMayor','TokenMayorIgual'),
           ('left','TokenIgual','TokenDesigual'),

           #Operadores aritmeticos
	       ('left','TokenSuma','TokenResta'),
	       ('left','TokenMult','TokenDivision',	'TokenResto'),

           #Operadores de Conjuntos
	       ('left','TokenUnion','TokenDiferencia'),
	       ('left','TokenInterseccion'),

           #Operadores Conjuntos-aritmeticos
	        ('left','TokenSumaCjto', 'TokenRestaCjto'),
           ('left','TokenMultCjto', 'TokenDivisionCjto','TokenRestoCjto'),
           ('left','TokenMaxValorCjto','TokenMinValorCjto','TokenNumElemCjto'),
           #Operadores Unarios
           ('right','TokenNegEnteros'),
           ('nonassoc','TokenContenCjto')
)

# diccionario of variables y de tipos
variables = { }
tipos     = { }

# Inicio del Programa
def p_programa(p):
    '''PROGRAMA : TokenProgram INSTRUCCION
                | TokenProgram BLOQUE'''
    p[0] = Program(p[2])
    print p[0].imprimir(0)

# Tipos
def p_tipo(p):
    '''TIPO : TokenInt
	        | TokenBool
            | TokenSet '''
    p[0] = Tipo(p[1])

# Definicion de instrucciones
def p_instruccion(p):
    ''' INSTRUCCION : SEC_INSTRUCCION
                    | ASIGNACION
                    | ENTRADA
                    | SALIDA
                    | CONDICIONAL
                    | ITERADOR_FOR
                    | ITERADOR_WHILE '''

# Secuencia de instrucciones
def p_sec_instrucciones(p):
    ' SEC_INSTRUCCION : INSTRUCCION TokenPuntoYComa INSTRUCCION'

# Instruccion Asignacion
def p_inst_asignacion(p):
    'ASIGNACION : VARIABLE TokenAsignacion EXPRESIONES '
    p[0] = Asignacion(p[1],p[3])

# Instruccion Bloque
def p_inst_bloque(p):
    '''BLOQUE : TokenLlaveAbre BLOQUE_DECLS INSTRUCCION TokenPuntoYComa TokenLlaveCier
              | TokenLlaveAbre INSTRUCCION TokenPuntoYComa TokenLlaveCier
              | TokenLlaveAbre TokenLlaveCier'''
    if (len(p) == 1):
       p[0] = Bloque(None,None)
       print p[0].imprimir(0)
    elif (len(p) == 3):
       p[0] = Bloque(None,p[2])
    else:
       p[0] = Bloque(p[2],p[3])

# Bloque Declaraciones
def p_bloque_decls(p):
    '''BLOQUE_DECLS : TokenUsing DECLARACIONES TokenIn'''

# Declaraciones
def p_declaraciones(p):
    '''DECLARACIONES : TIPO SEC_DECLS TokenPuntoYComa DECLARACIONES
                     | TIPO SEC_DECLS TokenPuntoYComa '''

# Secuencia de Declaraciones
def p_sec_decls(p):
    '''SEC_DECLS : VARIABLE TokenComa SEC_DECLS
                 | VARIABLE'''

# Instruccion de Entrada
def p_inst_entrada(p):
    'ENTRADA : TokenScan TIPO_ENTRADA'
    p[0] = Scan(p[2])

# tipos de Entrada
def p_tipo_entrada(p):
    '''TIPO_ENTRADA : VARIABLE
                    | BOOLEAN
                    | ENTERO'''
    p[0] = p[1]

# Instruccion de Salida
def p_inst_salida(p):
    '''SALIDA : TokenPrint    SEC_SALIDA
              | TokenPrintln  SEC_SALIDA'''

    if p[1] == 'Print':
       p[0] = Print(p[2])
    else:
       p[1] = PrintLn(p[2])

# Tipos de Salida
def p_inst_sec_salida(p):
    '''SEC_SALIDA : TIPO_SALIDA TokenComa SEC_SALIDA
                  | TIPO_SALIDA'''

#Tipo de salida
def p_tipo_salida(p):
    '''TIPO_SALIDA : VARIABLE
                   | CONJUNTO
                   | BOOLEAN
                   | ENTERO
                   | STRING'''
    p[0] = p[1]

# Instruccion de Condicional
def p_inst_if(p):
    '''CONDICIONAL : TokenIf CONDICION_BOOL INSTR_COND TokenPuntoYComa
                   | TokenIf CONDICION_BOOL TokenElse INSTR_COND TokenPuntoYComa
                   | TokenIf CONDICION_BOOL INSTR_COND TokenElse TokenIf CONDICION_BOOL INSTR_COND TokenElse INSTR_COND TokenPuntoYComa'''

# Condicion booleana
def p_cond_booleana(p):
    '''CONDICION_BOOL : TokenParAbre EXPRESIONES TokenParCierra'''

# Instruccion condicional con o sin bloque
def p_inst_cond(p):
    '''INSTR_COND : BLOQUE      TokenPuntoYComa
                  | INSTRUCCION TokenPuntoYComa'''

# Instruccion Iteradores determinado
def p_inst_iterador_for(p):
    '''ITERADOR_FOR : TokenFor TokenIdent TokenMin TIPO_EXPR_CONJUNTO TokenDo INSTR_ITERADOR
                    | TokenFor TokenIdent TokenMax TIPO_EXPR_CONJUNTO TokenDo INSTR_ITERADOR'''

# Instruccion Iteradores indeterminada
def p_inst_iterador_while(p):
    '''ITERADOR_WHILE : TokenRepeat INSTR_ITERADOR TokenWhile TokenParAbre EXPRESIONES TokenParCierra TokenDo INSTR_ITERADOR
                      | TokenWhile  TokenParAbre EXPRESIONES TokenParCierra TokenDo INSTR_ITERADOR
                      | TokenRepeat INSTR_ITERADOR TokenWhile TokenParAbre EXPRESIONES TokenParCierra'''

# Instruccion con o sin bloque para iteradores
def p_inst_iterador(p):
    '''INSTR_ITERADOR : BLOQUE      TokenPuntoYComa
                      | INSTRUCCION TokenPuntoYComa'''

# Expresiones
def p_expresiones(p):
    '''EXPRESIONES : EXPRESION_ARITMETICA
                   | EXPRE_ARIT_BOOLEAN
                   | EXPRE_ARIT_CONJUNTO
                   | EXPRE_UNARIA_CONJUNTO
                   | EXPRESION_BOOLEAN
                   | EXPRESION_CONJUNTO
                   | EXPRE_UNARIA
                   | ENTERO
                   | BOOLEAN
                   | VARIABLE'''

# Expresion aritmetica
def p_expr_aritmetica(p): #conjuntos
    '''EXPRESION_ARITMETICA : TIPO_EXPR_ARIT  TokenSuma     TIPO_EXPR_ARIT
                            | TIPO_EXPR_ARIT  TokenResta    TIPO_EXPR_ARIT
                            | TIPO_EXPR_ARIT  TokenMult     TIPO_EXPR_ARIT
                            | TIPO_EXPR_ARIT  TokenDivision TIPO_EXPR_ARIT
                            | TIPO_EXPR_ARIT  TokenResto    TIPO_EXPR_ARIT'''
    if   p[2] == '+':
         p[0] = OperadorBinario(p[1],p[2],p[3])
    elif p[2] == '-':
         p[0] = OperadorBinario(p[1],p[2],p[3])
    elif p[2] == '*':
         p[0] = OperadorBinario(p[1],p[2],p[3])
    elif p[2] == '/':
         p[0] = OperadorBinario(p[1],p[2],p[3])
    else:
         p[0] = OperadorBinario(p[1],p[2],p[3])

# Tipo de Expresion aritmetica simple o parentizada
def p_tipo_expr_aritm(p): #conjuntos
    '''TIPO_EXPR_ARIT : EXPRESION_ARITMETICA
                      | EXPRE_ARIT_PAREN
                      | TIPO_ARITMETICO'''

# Expresion aritmetica parentizada
def p_expr_arit_parentizada(p):
    '''EXPRE_ARIT_PAREN : TokenParAbre EXPRESION_ARITMETICA TokenParCierra'''

# Tipo aritmetico
def p_tipo_aritmetico(p):
    '''TIPO_ARITMETICO : ENTERO
                       | VARIABLE'''
    p[0] = p[1]

# Expresion aritmetica unaria
def p_expr_arit_unaria(p):
    ''' EXPRE_UNARIA : TokenResta EXPRESION_ARITMETICA %prec TokenNegEnteros'''

# Expresion aritmetica boolean
def p_expr_arit_boolean(p):
    '''EXPRE_ARIT_BOOLEAN : TIPO_EXPR_ARIT TokenContenCjto TIPO_EXPR_ARIT
	                      | TIPO_EXPR_ARIT TokenIgual      TIPO_EXPR_ARIT
                          | TIPO_EXPR_ARIT TokenDesigual   TIPO_EXPR_ARIT
	                      | TIPO_EXPR_ARIT TokenMenor      TIPO_EXPR_ARIT
	                      | TIPO_EXPR_ARIT TokenMenorIgual TIPO_EXPR_ARIT
	                      | TIPO_EXPR_ARIT TokenMayor      TIPO_EXPR_ARIT
	                      | TIPO_EXPR_ARIT TokenMayorIgual TIPO_EXPR_ARIT'''
    if p[2] == '@':
       p[0] = OperadorComparacionArit(p[1],p[2],p[3])
    elif p[2] == '==':
         p[0] = OperadorComparacionArit(p[1],p[2],p[3])
    elif p[2] == '/=':
         p[0] = OperadorBinarioArit(p[1],p[2],p[3])
    elif p[2] == '<':
         p[0] = OperadorComparacionArit(p[1],p[2],p[3])
    elif p[2] == '<=':
         p[0] = OperadorComparacionArit(p[1],p[2],p[3])
    elif p[2] == '>':
         p[0] = OperadorComparacionArit(p[1],p[2],p[3])
    else:
         p[0] = OperadorComparacionArit(p[1],p[2],p[3])

# Expresion aritmetica de conjunto
def p_expr_arit_conjunto(p):
    '''EXPRE_ARIT_CONJUNTO : TIPO_ARIT_CJTO_1 TokenSumaCjto     TIPO_ARIT_CJTO_2
                           | TIPO_ARIT_CJTO_1 TokenRestaCjto    TIPO_ARIT_CJTO_2
                           | TIPO_ARIT_CJTO_1 TokenMultCjto     TIPO_ARIT_CJTO_2
                           | TIPO_ARIT_CJTO_1 TokenDivisionCjto TIPO_ARIT_CJTO_2
                           | TIPO_ARIT_CJTO_1 TokenRestoCjto    TIPO_ARIT_CJTO_2'''
    if   p[2] == '<+>':
         p[0] = OperadorBinarioCjto(p[1],p[2],p[3])
    elif p[2] == '<->':
         p[0] = OperadorBinarioCjto(p[1],p[2],p[3])
    elif p[2] == '*':
         p[0] = OperadorBinarioCjto(p[1],p[2],p[3])
    elif p[2] == '</>':
         p[0] = OperadorBinarioCjto(p[1],p[2],p[3])
    else:
         p[0] = OperadorBinarioCjto(p[1],p[2],p[3])

# Expresion unaria de conjunto
def p_expr_unaria_conjunto(p):
    '''EXPRE_UNARIA_CONJUNTO : TokenMaxValorCjto TIPO_ARIT_CJTO_2
                             | TokenMinValorCjto TIPO_ARIT_CJTO_2
                             | TokenNumElemCjto  TIPO_ARIT_CJTO_2'''
    if p[1] == '>?':
       p[0] = OperadorUnarioCjto(p[1],p[2])
    elif p[1] == '<?':
        p[0] = OperadorUnarioCjto(p[1],p[2])
    else:
         p[0] = OperadorUnarioCjto(p[1],p[2])

# Tipo de 1er operando expresion aritmetica de conjunto
def p_tipo_expr_conjunto_1(p):
    '''TIPO_ARIT_CJTO_1 : VARIABLE
                        | ENTERO'''
    p[0] = p[1]

# Tipo de 2do operando expresion aritmetica de conjunto
def p_tipo_expr_conjunto_2(p):
    '''TIPO_ARIT_CJTO_2 : VARIABLE
                        | CONJUNTO'''
    p[0] = p[1]

# Expresion de conjunto
def p_expr_conjunto(p):
    '''EXPRESION_CONJUNTO : TIPO_EXPR_CONJUNTO TokenUnion        TIPO_EXPR_CONJUNTO
                          | TIPO_EXPR_CONJUNTO TokenDiferencia   TIPO_EXPR_CONJUNTO
                          | TIPO_EXPR_CONJUNTO TokenInterseccion TIPO_EXPR_CONJUNTO'''
    if   p[2] == '++':
         p[0] = OperadorBinarioCjto(p[1],p[2],p[3])
    elif p[2] == '\\':
         p[0] = OperadorBinarioCjto(p[1],p[2],p[3])
    else:
         p[0] = OperadorBinarioCjto(p[1],p[2],p[3])

# Tipo de expresion de conjunto
def p_tipo_expr_conjunto(p):
    '''TIPO_EXPR_CONJUNTO : VARIABLE
                          | CONJUNTO'''
    p[0] = p[1]

# Expresion Booleana
def p_expr_boolean(p):
    '''EXPRESION_BOOLEAN : TIPO_EXPR_BOOLEAN TokenAnd TIPO_EXPR_BOOLEAN
                         | TIPO_EXPR_BOOLEAN TokenOr  TIPO_EXPR_BOOLEAN
                         | TIPO_EXPR_BOOLEAN TokenNot TIPO_EXPR_BOOLEAN'''
    p[0] = OperadorBinario(p[1],p[2],p[3])

# Tipo de Expresion boolean simple o parentizada
def p_tipo_expr_boolean(p): #conjuntos
    '''TIPO_EXPR_BOOLEAN : EXPRESION_BOOLEAN
                         | EXPRE_BOOLEAN_PAREN
                         | TIPO_BOOLEAN'''
    p[0] = p[1]

# Tipo de Expresion boolean parentizada
def p_expr_bool_paren(p):
    '''EXPRE_BOOLEAN_PAREN : TokenParAbre EXPRESION_BOOLEAN TokenParCierra'''

# Tipo Boolean
def p_tipo_boolean(p):
    '''TIPO_BOOLEAN : VARIABLE
                    | BOOLEAN'''
    p[0] = p[1]

# Literal o String
def p_string(p):
    '''STRING : TokenString'''
    p[0] = String(p[1])

#Tipo conjunto
def p_conjunto(p):
    '''CONJUNTO : TokenLlaveAbre TokenLlaveCier
                | TokenLlaveAbre TIPO_CONJUNTO TokenLlaveCier
                | TokenLlaveAbre SEC_TIPO_CONJUNTO TokenLlaveCier'''

# Secuencia para el tipo conjunto
def p_sec_tipo_conjunto(p):
    '''SEC_TIPO_CONJUNTO : TIPO_CONJUNTO TokenComa SEC_TIPO_CONJUNTO
                         | TIPO_CONJUNTO'''

def p_tipo_conjunto(p):
    '''TIPO_CONJUNTO : VARIABLE
                     | ENTERO'''
    p[0] = p[1]

#Tipos Base Boolean
def p_boolean(p):
    '''BOOLEAN : TokenTrue
               | TokenFalse'''
    p[0] = Boolean(p[1])

#Tipos Base Entero
def p_entero(p):
    '''ENTERO : TokenNum'''
    p[0] = Number(p[1])

# VARIABLE
def p_variable(p):
    '''VARIABLE : TokenIdent'''
    p[0] = Variable(p[1])

# Error
def p_error(p):
    error = "Error: sintaxis "
    print error

##############################
# Arbol Sintactico Abstracto #
##############################

class Program:
    def __init__(self, decl):
        self.decl = decl
    def imprimir(self,posicion):
        return 'PROGRAM'

class Bloque:
    def __init__(self,bloque_dec,instruccion):
        self.bloque_dec = bloque_dec
        self.instruccion = instruccion
    def imprimir(self,tabs):
        print 'COMIENZO_BLOQUE\n'
        if (self.bloque_dec != None):
           print str(self.bloque_dec)
        if (self.instruccion != None):
           print str(self.instruccion)
        return 'FIN_BLOQUE\n'

class OperadorBinario:
	def __init__(self, opizq, operador, opder):
		self.izq = opizq
		self.operador = operador
		self.der = opder
	def __str__(self):
		return ('('+ str(self.operador) + ','  + str(self.izq)+ "," + str(self.der) + ')')

class OperadorBinarioCjto:
	def __init__(self, opizq, operador, opder):
		self.izq = opizq
		self.operador = operador
		self.der = opder
	def __str__(self):
		return ('('+ str(self.operador) + ','  + str(self.izq)+ "," + str(self.der) + ')')

class OperadorComparacionArit:
	def __init__(self, opizq, operador, opder):
		self.izq = opizq
		self.operador = operador
		self.der = opder
	def __str__(self):
		return ('(' + str(self.operador) + ','  + str(self.izq)+ "," + str(self.der) + ')')

class OperadorUnario:
	def __init__(self, operador, opder):
		self.operador = operador
		self.der = opder
	def __str__(self):
		return '(' + str(self.operador) + ',' + str(self.der) +')'

class NegBooleana:
	def __init__(self,expresion):
		self.e = expresion
	def __str__(self):
		return '('+ "NOT" + "," + str(self.e) + ')'

class Variable :
	def __init__(self,variable):
		self.variable = variable
	def __str__(self):
		return "variable" + '(' + str(self.variable) + ')'

class String:
	def __init__(self, value):
		self.type = "string"
		self.value = value
	def __str__(self):
		return "string" + '(' + str(self.value) + ')'

class Number:
	def __init__(self,value):
	        self.type = "number"
	        self.value = value
	def __str__(self):
		return "num" +'(' +str(self.value) +')'

class Boolean:
	def __init__(self,boolean) :
		self.boolean = boolean
	def __str__(self):
		return "Boolean" + str(self.boolean)

class Asignacion:
	def __init__(self,vari,expre) :
		self.vari = vari
		self.expre = expre
	def __str__(self):
		return   str(self.vari) + " := " + str(self.expre)

class Tipo:
	def __init__(self,tipo):
		self.tipo = tipo
	def __str__(self):
		return   ": " + str(self.tipo)

if __name__ == "__main__":

# Comprueba si se introdujeron los parametros correctamente
    if len(sys.argv)!=2:
        print "Los argumentos introducidos son incorrectos."
        exit(1)

    # Abrir archivo y comprueba si existe tal archivo
    try:
       if re.match("[\w|\W]*[.]stl",sys.argv[1]):
          archivo = open(sys.argv[1],'r')
       else:
          exit(1)
    except:
       print "Error en el archivo "+ sys.argv[1]
       exit(1)

    # Listas que almacena los errores del lexer encontrado
    ListaErroresLexer = []

    arch = archivo.read()
    # Construccion del Lexer
    lexer = lex.lex()
    linea = archivo.readline()
    lexer.input(linea)
    while True:
       while True:
           tok = lexer.token()
           if not tok: break        # No mas tokens para extraer
           if tok.type  == "error": #Si hay errores
              ListaErrores.append(tok.value)
       linea = archivo.readline()
       if not linea: break
       lexer.input(linea)

    #Imprime los errores encotrados
    if not len(ListaErroresLexer)==0:
       i=0
       while i<len(ListaErroresLexer):
          print ListaErroresLexer[i]
          i = i+1
    else:
       #Se construye el parser
       parser = yacc.yacc()
       salida = parser.parse(arch)

    #Cierra el archivo
    archivo.close()