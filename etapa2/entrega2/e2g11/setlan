#!/usr/bin/env python
# -*- coding: utf-8 -*-

#Jesus Sanchez 10-10898
#Jose Barrientos 10-10800
#Entrega 2 ci-3725

import ply.lex as lex
import ply.yacc as yacc
import sys
import warnings
warnings.filterwarnings("ignore")

#inicializacion de listas de tokens y errores encontrados
lexer_tokens = []
lexer_errores = []

#lista de palabras reservadas
reserved = {
    'if' : 'IF',
    'else' : 'ELSE',
    'while' : 'WHILE',
    'do' : 'DO',
    'for' : 'FOR',
    'repeat' : 'REPEAT',
    'in' : 'IN',
    'program' : 'PROGRAM',
    'using' : 'USING',
    'set' : 'SET',
    'print' : 'PRINT',
    'println' : 'PRINTLN',
    'bool' : 'BOOL',
    'int' : 'INT',
    'scan' : 'SCAN',
    'not' : 'NOT',
    'and' : "AND",
    'or' : "OR",
    'min' : "MIN",
    'max' : "MAX"
}

#lista de tokens definidos
tokens = list(reserved.values()) + [

    'NUMERO','TRUE','FALSE','STRING','ID',
    'PLUS','MINUS','TIMES','DIVIDE','LPAREN','RPAREN',
    'SEMICOLON','EQUIV','ASIGNA','COMA','MODULE',
    'LESSTEQ','LESST','GREATEQ', 'GREATT','NOTEQ',
    'UNION', 'DIFERENCIA', 'INTERSECT', 'PLUSCONJ',
    'MINUSCONJ','TIMESCONJ', 'DIVCONJ','RESTOCONJ',
    'MAXCONJ', 'MINCONJ', 'SIZECONJ', 'CONTIENECONJ',
    'LLAVEIZ', 'LLAVEDE'

]

#expresiones regulares para atrapar tokens

t_PLUS    = r'\+'
t_MINUS   = r'-'
t_TIMES   = r'\*'
t_DIVIDE  = r'/'
t_LPAREN  = r'\('
t_RPAREN  = r'\)'
t_SEMICOLON = r';'
t_EQUIV = r'=='
t_ASIGNA = r'='
t_COMA = r','
t_MODULE = r'%'
t_LESSTEQ = r'<='
t_LESST = r'<'
t_GREATEQ = r'>='
t_GREATT = r'>'
t_NOTEQ = r'/='
t_UNION  = r'\+\+'
t_DIFERENCIA  = r'\\'
t_INTERSECT  = r'><'
t_PLUSCONJ  = r'<\+>'
t_MINUSCONJ  = r'<\->'
t_TIMESCONJ  = r'<\*>'
t_DIVCONJ  = r'</>'
t_RESTOCONJ  = r'<%>'
t_MAXCONJ  = r'>\?'
t_MINCONJ  = r'<\?'
t_SIZECONJ  = r'\$\?'
t_CONTIENECONJ  = r'@'
t_LLAVEIZ = r'{'
t_LLAVEDE = r'}'
t_ignore  = ' \t'

#funcion que identifica un token NUMERO y guarda su valor entero
def t_NUMERO(t):
    r'\d+'
    if((int(t.value)>2147483647) or (int(t.value)+ 2147483648)<0):
        print "El numero introducido excede 32 bits"
        exit(0)
    else:
        t.value = int(t.value)
    return t

#funcion que identifica un token TRUE y guarda su valor booleano
def t_TRUE(t):
    r'(\btrue\b)'
    t.value = "true"
    return t

#funcion que identifica un token FALSE y guarda su valor booleano
def t_FALSE(t):
    r'(\bfalse\b)'
    t.value = "false"
    return t

#funcion que identifica un token STRING y lo retorna
def t_STRING(t):
    r'\"([^\n\"\\]|\\n|\\"|\\\\)*\"'
    return t

#funcion que identifica un token ID para nombres de variables
def t_ID(t):
    r'[a-zA-Z_][a-zA-Z_0-9]*'
    t.type = reserved.get(t.value,'ID')
    return t

#metodo que identifica saltos de linea
def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

#metodo que identifica comentarios
def t_COMMENT(t):
    r'\#.*'

#funcion que calcula la columna de la palabra o simbolo que lee actualmente
def calcular_columna(input, tok):
    ultimo_salto = input.rfind('\n', 0, tok.lexpos)
    if ultimo_salto < 0:
        ultimo_salto = 0
    else:
        ultimo_salto += 1;
    columna = (tok.lexpos - ultimo_salto) + 1
    return columna

#metodo que almacena palabras o simbolos inesperadas en la lista de errores
def t_error(t):
    lexer_errores.append("Error: Se ha conseguido un caracter inesperado '%s' en linea %s, columna %s." %(t.value[0],t.lineno,str(calcular_columna(t.lexer.lexdata,t))))
    t.lexer.skip(1)


#metodo que almacena palabras o simbolos en la lista de tokens encontrados
def buscar(input, lexer):
    global lexer_tokens
    lexer.input(input)
    while True:
        tok = lexer.token()
        if not tok:
            break
        lexer_tokens.append(tok)

lexer = lex.lex()  

#################################################################################

indentar= ""
indentarbloque= ""

def agregar(indentar):
	return indentar+"\t"


def eliminar(indentar):
	return indentar[:-1]

class cnum:
    def __init__(self, numero):
        self.numero = numero
    def __str__(self):
        global indentar
        s= "CONSTANTE_ENT"
        indentar=agregar(indentar)
        s=s+"\n"+indentar+"valor: "+str(self.numero)
        indentar=eliminar(indentar)
        return s

class cbool:
    def __init__(self, boo):
        self.boo = boo
    def __str__(self):
        global indentar
        s= "CONSTANTE_BOOL"
        indentar=agregar(indentar)
        s=s+"\n"+indentar+"valor: "+str(self.boo)
        indentar=eliminar(indentar)
        return s

class variable:
    def __init__(self, ident):
        self.ident = ident
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s = "VARIABLE \n"+indentar+"nombre: "+str(self.ident)
        indentar=eliminar(indentar)
        return s

class unario:
    def __init__(self,oper,ident):
        if(oper=='-'):
            self.oper= 'menos unario'
        elif(oper=='>?'):
            self.oper= 'max conjunto'
        elif(oper=='<?'):
            self.oper= 'min conjunto'
        elif(oper=='$?'):
            self.oper= 'tamanio conjunto'
        else:
            self.oper = 'not'
        self.ident = ident
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= "EXPRESION_UN\n"+indentar+"operador: "+str(self.oper)+"\n"+indentar+"operando: "+str(self.ident)
        indentar=eliminar(indentar)
        return s

class binario:
    def __init__(self,prim,oper,seg):
        self.prim = prim
        if(oper=='+'):
            self.oper='mas'
        elif(oper=='-'):
            self.oper='resta'
        elif(oper=='*'):
            self.oper='por'
        elif(oper=='/'):
            self.oper='division'
        elif(oper=='%'):
            self.oper='modulo'
        elif(oper=='<'):
            self.oper='menor que'
        elif(oper=='>'):
            self.oper='mayor que'
        elif(oper=='<='):
            self.oper='menor o igual que'
        elif(oper=='>='):
            self.oper='mayor o igual que'
        elif(oper=='=='):
            self.oper='equivalente'
        elif(oper=='/='):
            self.oper='no igual a'
        elif(oper=='><'):
            self.oper='interseccion'
        elif(oper=='++'):
            self.oper='union'
        elif(oper=='<+>'):
            self.oper='suma mapeada'
        elif(oper=='<->'):
            self.oper='resta mapeada'
        elif(oper=='<*>'):
            self.oper='multiplicacion mapeada'
        elif(oper=='</>'):
            self.oper='division mapeada'
        elif(oper=='<%>'):
            self.oper='resto division mapeada'
        elif(oper=='@'):
            self.oper='contencion conjunto'
        elif(oper=='or'):
            self.oper='or'
        elif(oper=='and'):
            self.oper = 'and'
        else:
            self.oper = 'diferencia'
        self.seg = seg
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= "EXPRESION_BIN\n"+indentar+"operador: "+str(self.oper)+"\n"+indentar+"operando izq: "+str(self.prim)+"\n"+indentar+"operando der: "+str(self.seg)
        indentar=eliminar(indentar)
        return s

class elemconj:
    def __init__(self,num,val):
        self.num = num
        self.val = val
    def __str__(self):
        global indentar
        s=str(self.num)+"\n"+indentar+str(self.val)
        return s
  
class conjunto:
    def __init__(self,nom):
        self.nom = nom
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= "CONJUNTO\n"+indentar+"MIEMBROS: \n"+indentar+str(self.nom)+"\n"+indentar
        indentar=eliminar(indentar)
        return s

class separa:
    def __init__(self,val1,val2):
        self.val1 = val1
        self.val2 = val2
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= indentar+""+str(self.val1)+"\n"+indentar+"SEPARADOR"
        indentar=eliminar(indentar)
        s=s+"\n"+str(self.val2)
        return s

class chain:
    def __init__(self,nom):
        self.nom = nom
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= "CADENA\n"+indentar+"valor: "+str(self.nom)
        indentar=eliminar(indentar)
        return s
      
class lectura:
    def __init__(self,nom):
        self.nom = nom
    def __str__(self):
        global indentar
        s= "SCAN"
        indentar=agregar(indentar)
        s= s+"\n"+indentar+"variable: "+str(self.nom)
        indentar=eliminar(indentar)
        return s

class escritura:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        if (str(self.nom)=='print'):
            s= str(self.nom).upper()+"\n"
            s= s+""+indentar+"elemento: "+str(self.val)
        else:
            s= "PRINT\n"
            s= s+""+indentar+"elemento: "+str(self.val)
            s= s+"\n"+indentar+"elemento: CADENA"
            indentar=agregar(indentar)
            s= s+"\n"+indentar+"valor: \\n"
            indentar=eliminar(indentar)
        indentar=eliminar(indentar)
        return s

class inicio:
    def __init__(self,nom):
        self.nom = nom
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= "\n"+"PROGRAM"+"\n"+indentar+str(self.nom)
        indentar=eliminar(indentar)
        return s
      
class inicializar:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        if (self.val!=""):
            s= indentar+"USING: "
            indentar=agregar(indentar)
            s= s+str(self.nom)
            indentar=eliminar(indentar)
            s= s+"\n"+indentar+"IN: "+"\n"+str(self.val)
        else:
            s= indentar+str(self.nom)
        indentar=eliminar(indentar)
        return s

class ausar:
    def __init__(self,nom,val):
       self.nom = nom
       self.val = val
    def __str__(self):
        global indentar

        if (self.val!=""):
            s= str(self.nom)+str(self.val)
        else:
            s=str(self.nom)   
        return s
      
class diferenciar:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        s="\n"+indentar+str(self.nom)+" "+str(self.val)
        return s

class organizar:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        s=str(self.nom)+str(self.val)
        return s	      

class sonvarios:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        s= str(self.nom)+", "+str(self.val)   
        return s

class bloque:
    def __init__(self,nom):
        self.nom = nom
    def __str__(self):
        global indentar
        indentarbloque = indentar
        s= "BLOQUE"
        s= s+"\n"+str(self.nom)
        s= s+"\n"+indentarbloque+"FINAL DEL BLOQUE"
        return s

class asignacion:
    def __init__(self,nom,val):
        self.nom = nom
        self.val = val
    def __str__(self):
        global indentar
        s= "ASIGNACION"
        indentar=agregar(indentar)
        s= s+"\n"+indentar+"var: "+str(self.nom)+"\n"+indentar+"val: "+str(self.val)
        indentar=eliminar(indentar)
        return s

class condicional:
    def __init__(self,nom,val,otro):
        self.nom = nom
        self.val = val
        self.otro = otro
    def __str__(self):
        global indentar
        s= "CONDICIONAL"
        indentar=agregar(indentar)
        if (self.otro!=""):
            s= s+"\n"+indentar+"condicion: "+str(self.nom)+"\n"+indentar+"eval_true: "
            indentar=agregar(indentar)
            s= s+"\n"+indentar+str(self.val)
            indentar=eliminar(indentar)
            s= s+"\n"+indentar+"eval_false: "
            indentar=agregar(indentar)
            s= s+"\n"+indentar+str(self.otro)
            indentar=eliminar(indentar)
        else:
            s= s+"\n"+indentar+"condicion: "+str(self.nom)+"\n"+indentar+"eval_true: "
            indentar=agregar(indentar)
            s= s+"\n"+indentar+str(self.val)
            indentar=eliminar(indentar)
        indentar=eliminar(indentar)
        return s

class iterindet:
    def __init__(self,nom,val,otro):
        self.nom = nom
        self.val = val
        self.otro = otro
    def __str__(self):
        global indentar
        s= "ITERACION_INDET"
        indentar=agregar(indentar)
        if (self.otro!=""):
            s= s+"\n"+indentar+"instruccion 1: "
            indentar=agregar(indentar)
            s= s+"\n"+indentar+str(self.nom)
            indentar=eliminar(indentar)
            s= s+"\n"+indentar+"condicion: "+str(self.val)+"\n"+indentar+"instruccion 2: "
            indentar=agregar(indentar)
            s= s+"\n"+indentar+str(self.otro)
            indentar=eliminar(indentar)
        else:
            s= s+"\n"+indentar+"condicion: "+str(self.val)+"\n"+indentar+"instruccion: "
            indentar=agregar(indentar)
            s= s+"\n"+indentar+str(self.nom)
            indentar=eliminar(indentar)
        indentar=eliminar(indentar)
        return s

class iterdet:
    def __init__(self,nom,direc,val,foo):
        self.nom = nom
        self.direc = direc
        self.val = val
        self.foo = foo
    def __str__(self):
        global indentar
        s= "ITERACION_DET"
        indentar=agregar(indentar)
        s= s+"\n"+indentar+"variable: "+str(self.nom)+"\n"+indentar+"direccion: "+str(self.direc)+"\n"+indentar+"rango: "+str(self.val)+"\n"+indentar+"instruccion: "
        indentar=agregar(indentar)
        s= s+"\n"+indentar+str(self.foo)
        indentar=eliminar(indentar)
        indentar=eliminar(indentar)
        return s

class auxiliar:
    def __init__(self,nom):
        self.nom= nom
    def __str__(self):
        global indentar
        indentar=agregar(indentar)
        s= indentar+""+str(self.nom)
        return s

class escribedos:
    def __init__(self,nom,val):
        self.nom= nom
        self.val= val
    def __str__(self):
        global indentar
        s= str(self.nom)+"\n"+indentar+"elemento: "+str(self.val)
        return s

#################################################################################

start = 'program'

precedence = ( 
    ('left','OR'),
    ('left','AND'),
    ('right','NOT'),
    ('nonassoc','LESST','LESSTEQ','GREATT','GREATEQ'),
    ('nonassoc','NOTEQ','EQUIV'),
    ('nonassoc','CONTIENECONJ'),
    ('left','PLUS','MINUS'),
    ('left','TIMES','DIVIDE','MODULE'),
    ('left','PLUSCONJ','MINUSCONJ'),
    ('left','TIMESCONJ','DIVCONJ','RESTOCONJ'),
    ('left','UNION','DIFERENCIA'),
    ('left','INTERSECT'),
    ('right','UMINUS','MAXCONJ','MINCONJ','SIZECONJ'),
    ('nonassoc','LPAREN','RPAREN')
)

#Gramatica
#principal
def p_prog(p): 
    'program : PROGRAM instruccion'
    p[0]= inicio(p[2])

# Tipos de datos
def p_tipo(p):
    '''tipo : INT vars
        | SET vars
        | BOOL vars '''
    p[0]=diferenciar(p[1],p[2])

def p_variostipos(p):
    '''variostipos : tipo variostipos
        | tipo'''
    if(len(p)==3):
        p[0]= ausar(p[1],p[2])
    else:
        p[0]= ausar(p[1],"")

# Variables a declarar
def p_vars(p):
    '''vars : varios SEMICOLON
        | ID SEMICOLON tipo
        | ID SEMICOLON'''
    if(len(p)==4):
        p[0]= organizar(p[1],p[3])
    else:
        p[0]= organizar(p[1],"")

#Secuencia de elementos separados por coma
def p_varios(p):
    '''varios : ID COMA varios
        | ID COMA ID'''
    p[0]= sonvarios(p[1],p[3])	  

#Expresiones binarias, constantes,variables, unarios y funciones incluyendo parentesis
def p_expBinUnFun(p): 
    '''expBinUnFun : LPAREN expBinUnFun RPAREN
        | expBinUnFun TIMES expBinUnFun
        | expBinUnFun DIVIDE expBinUnFun
        | expBinUnFun MODULE expBinUnFun
        | expBinUnFun PLUS expBinUnFun
        | expBinUnFun MINUS expBinUnFun
        | expBinUnFun LESSTEQ expBinUnFun
        | expBinUnFun LESST expBinUnFun
        | expBinUnFun GREATEQ expBinUnFun
        | expBinUnFun GREATT expBinUnFun
        | expBinUnFun EQUIV expBinUnFun
        | expBinUnFun NOTEQ expBinUnFun
        | expBinUnFun AND expBinUnFun
        | expBinUnFun OR expBinUnFun
        | expBinUnFun UNION expBinUnFun
        | expBinUnFun INTERSECT expBinUnFun
        | expBinUnFun DIFERENCIA expBinUnFun
        | expBinUnFun CONTIENECONJ expBinUnFun
        | expBinUnFun PLUSCONJ expBinUnFun
        | expBinUnFun MINUSCONJ expBinUnFun
        | expBinUnFun TIMESCONJ expBinUnFun
        | expBinUnFun DIVCONJ expBinUnFun
        | expBinUnFun RESTOCONJ expBinUnFun
        | MINUS expBinUnFun %prec UMINUS
        | LLAVEIZ elementosconj LLAVEDE
        | NOT expBinUnFun
        | MAXCONJ expBinUnFun
        | MINCONJ expBinUnFun
        | SIZECONJ expBinUnFun
        | NUMERO 
        | TRUE 
        | FALSE
        | ID'''

    if(len(p)==2):
        if(str(p[1]).isdigit()):
            p[0]= cnum(p[1])
        elif(p[1]=='true' or p[1]=='false'):
            p[0]= cbool(p[1])
        else:
            p[0]= variable(p[1])
    elif(len(p)==3):
        p[0]= unario(p[1],p[2])
    elif(len(p)==4):
        if(p[3]==')'):
            p[0]= p[2]
        elif(p[1]=='{'):
            p[0]= conjunto(p[2])
        else:
            p[0]= binario(p[1],p[2],p[3])

# Regla para trabajar elementos sobre conjunto
def p_elementosconj(p):
    ''' elementosconj : expBinUnFun COMA elementosconj
        | expBinUnFun
        | ''' # Vacio
    if(len(p)==1):
        p[0]= "Vacio"
    elif(len(p)==2):
        p[0]= p[1]
    else:
        p[0]= elemconj(p[1],p[3])

# Operacion string a imprimir uno o varios
def p_aImprimir(p):
    ''' aImprimir : expBinUnFun COMA aImprimir
        | expBinUnFun 
        | cadena COMA aImprimir
        | cadena'''
    if(len(p)==2):
        p[0]= p[1]
    else:
        p[0]= escribedos(p[1],p[3])

# Instrucciones
def p_instruccion(p):
    ''' instruccion : LLAVEIZ DeclaracionInstrucion LLAVEDE
        | ID ASIGNA expBinUnFun
        | SCAN ID
        | PRINTLN aImprimir
        | PRINT aImprimir
        | IF LPAREN expBinUnFun RPAREN instruccion ELSE instruccion
        | IF LPAREN expBinUnFun RPAREN instruccion
        | FOR ID MIN expBinUnFun DO instruccion
        | FOR ID MAX expBinUnFun DO instruccion
        | REPEAT instruccion WHILE LPAREN expBinUnFun RPAREN DO instruccion
        | WHILE LPAREN expBinUnFun RPAREN DO instruccion
        | REPEAT instruccion WHILE LPAREN expBinUnFun RPAREN'''

    if(len(p)==3):
        if(p[1]=='scan'):
            p[0]= lectura(p[2])
        else:
            p[0]= escritura(p[1],p[2])
    elif(len(p)==4):
        if(p[1]=='{'):
            p[0]= bloque(p[2])
        else:
            p[0]= asignacion(p[1],p[3])
    elif(len(p)==6):	
        p[0]= condicional(p[3],p[5],"")
    elif(len(p)==7):
        if(p[1]=='for'):
            p[0]= iterdet(p[2],p[3],p[4],p[6])
        elif(p[1]=='repeat'):
            p[0]= iterindet(p[2],p[5],"")
        else:
            p[0]= iterindet(p[6],p[3],"")
    elif(len(p)==8):
        p[0]= condicional(p[3],p[5], p[7])
    else:
        p[0]= iterindet(p[2],p[5],p[8])

# Instrucciones internas
def p_variasInstr(p):
    ''' variasInstr : instruccion SEMICOLON variasInstr
        | instruccion SEMICOLON'''
    if(len(p)==4):
        p[0]= separa(p[1],p[3])
    else:
        p[0]= auxiliar(p[1])

#Declaracion de variables
def p_DeclaracionInstrucion(p):
    ''' DeclaracionInstrucion : USING variostipos IN variasInstr
        | variasInstr
        | ''' #Vacio
    if(len(p)==1):
        p[0]=inicializar("","")
    elif(len(p)==2):
        p[0]=p[1]
    else:
        p[0]=inicializar(p[2],p[4])

#Cadena
def p_cadena(p):
    'cadena : STRING'
    p[0]= chain(p[1])

#Permite la deteccion de errores y detencion del programa cuando esto sucede	
def p_error(p):
    if( p is None ):
        print "Error de sintaxis al final del archivo"	
    else:
        print "Error de sintaxis en linea '%s', columna '%s': token '%s' inesperado"%(str(p.lineno),str(calcular_columna(p.lexer.lexdata,p)),str(p.value))
    sys.exit(0)

#################################################################################

#Principal
if __name__ == '__main__':

    if(len(sys.argv) != 2):
        print "Falta un argumento. \nDebe ser: ./setlan Archivo.extension"
    else:
        archivo = sys.argv[1]
        data=""
        try:
            fh = open(archivo, 'r')
            data = fh.read()
            fh.close()
            buscar(data, lexer)
            if len(lexer_errores) > 0:
                for tok in lexer_errores:
                    print(tok)
            else:
                lexer.lineno=1
                parser = yacc.yacc()
                arbol = parser.parse(data)
                print arbol
        except IOError:
            print 'No se puede abrir el archivo:', archivo